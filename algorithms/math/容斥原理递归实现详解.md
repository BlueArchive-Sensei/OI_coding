# 🧮 递归版本容斥原理详解

## 📊 问题描述

计算在 `1` 到 `N` 之间，所有是 `a1` 或 `a2` 或 `a3` 或 ... 或 `an` 的倍数的数字个数。

## 🎯 容斥原理核心思想

容斥原理的数学公式：
```
|A1 ∪ A2 ∪ ... ∪ An| = Σ|Ai| - Σ|Ai ∩ Aj| + Σ|Ai ∩ Aj ∩ Ak| - ... + (-1)^(n+1)|A1 ∩ A2 ∩ ... ∩ An|
```

其中：
- `Ai` 表示在 `[1,N]` 中是 `ai` 的倍数的集合
- `|Ai| = N / ai`
- `|Ai ∩ Aj| = N / lcm(ai, aj)`

## 🔄 递归实现原理

### 核心递归函数

```cpp
long long inclusion_exclusion_recursive(const vector<long long>& nums, int index, 
                                       long long current_lcm, int count, long long N)
```

**参数说明：**
- `nums`: 给定的数字数组
- `index`: 当前考虑的数字下标
- `current_lcm`: 当前选中数字的最小公倍数
- `count`: 当前选中的数字个数
- `N`: 范围上限

### 递归逻辑

对于每个数字 `nums[index]`，我们有两个选择：

1. **不包含这个数字**：
   ```cpp
   inclusion_exclusion_recursive(nums, index + 1, current_lcm, count, N)
   ```

2. **包含这个数字**：
   ```cpp
   new_lcm = lcm(current_lcm, nums[index])
   inclusion_exclusion_recursive(nums, index + 1, new_lcm, count + 1, N)
   ```

### 贡献计算

到达递归终点时：
- 如果选中了 `count` 个数字，贡献为 `N / current_lcm`
- 根据容斥原理：
  - 奇数个数字：`+贡献`
  - 偶数个数字：`-贡献`

## ✅ 正确性证明

### 📈 二项式定理证明

对于 `[1,N]` 范围内的任意数字 `x`：

1. **设 `x` 是 `k` 个给定数字的倍数**

2. **在容斥计算中，`x` 会被计算的次数为：**
   ```
   C(k,1) - C(k,2) + C(k,3) - C(k,4) + ... + (-1)^(k+1) * C(k,k)
   ```

3. **根据二项式定理：**
   ```
   (1-1)^k = Σ(i=0 to k) (-1)^i * C(k,i) = 0  (当 k > 0)
   ```

4. **展开得到：**
   ```
   C(k,0) - C(k,1) + C(k,2) - C(k,3) + ... + (-1)^k * C(k,k) = 0
   ```

5. **移项得到：**
   ```
   C(k,1) - C(k,2) + C(k,3) - ... + (-1)^(k+1) * C(k,k) = C(k,0) = 1
   ```

6. **结论：**
   - 当 `k > 0` 时：数字 `x` 最终被计算 `1` 次 ✅
   - 当 `k = 0` 时：数字 `x` 最终被计算 `0` 次 ✅

这正是我们想要的结果！

## 📝 实际验证示例

### 测试用例：1到100中是2或3或5的倍数

**直接计算：**
- 2的倍数：`100/2 = 50` 个
- 3的倍数：`100/3 = 33` 个  
- 5的倍数：`100/5 = 20` 个
- 6的倍数（2∩3）：`100/6 = 16` 个
- 10的倍数（2∩5）：`100/10 = 10` 个
- 15的倍数（3∩5）：`100/15 = 6` 个
- 30的倍数（2∩3∩5）：`100/30 = 3` 个

**容斥计算：**
```
50 + 33 + 20 - 16 - 10 - 6 + 3 = 74
```

**程序输出：** `74` ✅

## 🚀 复杂度分析

- **时间复杂度：** `O(2^n * log(max_value))`
  - `2^n`：枚举所有子集
  - `log(max_value)`：计算 GCD 的复杂度

- **空间复杂度：** `O(n)`
  - 递归调用栈的深度

## 💡 优化技巧

1. **去重处理：** 移除重复数字
2. **过滤无效数字：** 移除大于 `N` 的数字
3. **提前剪枝：** 当 `LCM > N` 时提前返回
4. **避免溢出：** 计算 `LCM` 时先除后乘

## 🎊 千禧年科技学院点评

**アリス会长：** "这个递归实现很优雅，体现了分治思想的精髓！"

**ユウカ：** "二项式定理的证明很严谨，数学基础扎实！"

**ユズ部长：** "代码可读性很高，注释详细，便于理解和维护！"

---

*© 2024 千禧年科技学院 - 算法竞赛部* 