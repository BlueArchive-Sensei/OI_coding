# ğŸŒ¸ æ‹Ÿé˜µç†è®ºä¸è´ªå¿ƒç®—æ³•
## *åƒç¦§å¹´ç§‘æŠ€å­¦é™¢ - ãƒ¦ã‚¦ã‚«æ•°å­¦ä¸“é¢˜*

*"æ‹Ÿé˜µç†è®ºæ˜¯è´ªå¿ƒç®—æ³•çš„ç†è®ºåŸºç¡€ï¼Œè®©æˆ‘ä»¬ä¸€èµ·æ¢ç´¢è¿™ä¸ªä¼˜ç¾çš„æ•°å­¦ç»“æ„ï¼"*

---

## ğŸ“š ç›®å½•

1. [æ‹Ÿé˜µçš„åŸºç¡€æ¦‚å¿µ](#æ‹Ÿé˜µçš„åŸºç¡€æ¦‚å¿µ)
2. [æ‹Ÿé˜µçš„æ€§è´¨ä¸å®šç†](#æ‹Ÿé˜µçš„æ€§è´¨ä¸å®šç†)
3. [è´ªå¿ƒç®—æ³•ä¸æ‹Ÿé˜µ](#è´ªå¿ƒç®—æ³•ä¸æ‹Ÿé˜µ)
4. [æœ€å°ç”Ÿæˆæ ‘çš„æ‹Ÿé˜µè¯æ˜](#æœ€å°ç”Ÿæˆæ ‘çš„æ‹Ÿé˜µè¯æ˜)
5. [ç½‘ç»œæµä¸æ‹Ÿé˜µ](#ç½‘ç»œæµä¸æ‹Ÿé˜µ)
6. [å…¶ä»–ç»å…¸åº”ç”¨](#å…¶ä»–ç»å…¸åº”ç”¨)
7. [ç¼–ç¨‹å®ç°](#ç¼–ç¨‹å®ç°)

---

## ğŸ¯ æ‹Ÿé˜µçš„åŸºç¡€æ¦‚å¿µ

### å®šä¹‰

**æ‹Ÿé˜µ (Matroid)** æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ `M = (S, I)`ï¼Œå…¶ä¸­ï¼š
- `S` æ˜¯ä¸€ä¸ªæœ‰é™çš„åŸºæœ¬é›†åˆ
- `I` æ˜¯ `S` çš„å­é›†æ—ï¼Œç§°ä¸º**ç‹¬ç«‹é›†æ—**

æ‹Ÿé˜µå¿…é¡»æ»¡è¶³ä»¥ä¸‹ä¸‰ä¸ªå…¬ç†ï¼š

#### ğŸ”¹ å…¬ç† 1ï¼šéç©ºæ€§
```
âˆ… âˆˆ I  (ç©ºé›†æ˜¯ç‹¬ç«‹é›†)
```

#### ğŸ”¹ å…¬ç† 2ï¼šé—ä¼ æ€§ (Hereditary Property)
```
å¦‚æœ B âˆˆ I ä¸” A âŠ† Bï¼Œåˆ™ A âˆˆ I
```
*ä»»ä½•ç‹¬ç«‹é›†çš„å­é›†ä¹Ÿæ˜¯ç‹¬ç«‹é›†*

#### ğŸ”¹ å…¬ç† 3ï¼šäº¤æ¢æ€§ (Exchange Property)
```
å¦‚æœ A, B âˆˆ I ä¸” |A| < |B|ï¼Œ
åˆ™å­˜åœ¨ x âˆˆ B\A ä½¿å¾— A âˆª {x} âˆˆ I
```
*è¾ƒå°çš„ç‹¬ç«‹é›†æ€»èƒ½ä»è¾ƒå¤§çš„ç‹¬ç«‹é›†ä¸­"å€Ÿç”¨"ä¸€ä¸ªå…ƒç´ æ‰©å±•*

### ğŸŒŸ é‡è¦æ¦‚å¿µ

#### åŸº (Base)
**åŸº** æ˜¯æå¤§ç‹¬ç«‹é›†ï¼Œå³ä¸èƒ½å†æ·»åŠ ä»»ä½•å…ƒç´ çš„ç‹¬ç«‹é›†ã€‚

**å®šç† 1**ï¼šæ‰€æœ‰åŸºçš„å¤§å°ç›¸ç­‰ã€‚
```
è®¾ Bâ‚, Bâ‚‚ æ˜¯ä¸¤ä¸ªåŸºï¼Œåˆ™ |Bâ‚| = |Bâ‚‚|
```

**è¯æ˜**ï¼š
- å‡è®¾ |Bâ‚| < |Bâ‚‚|
- ç”±äº¤æ¢æ€§ï¼Œå­˜åœ¨ x âˆˆ Bâ‚‚\Bâ‚ ä½¿å¾— Bâ‚ âˆª {x} âˆˆ I
- è¿™ä¸ Bâ‚ æ˜¯æå¤§ç‹¬ç«‹é›†çŸ›ç›¾
- åŒç†å¯è¯ |Bâ‚‚| â‰® |Bâ‚|
- å› æ­¤ |Bâ‚| = |Bâ‚‚|

#### ç§© (Rank)
æ‹Ÿé˜µçš„**ç§©** `r(M)` æ˜¯ä»»æ„åŸºçš„å¤§å°ã€‚

å¯¹äº `A âŠ† S`ï¼Œ`A` çš„ç§© `r(A)` æ˜¯ `A` ä¸­æœ€å¤§ç‹¬ç«‹é›†çš„å¤§å°ã€‚

#### å›è·¯ (Circuit)
**å›è·¯** æ˜¯æå°ç›¸å…³é›†ï¼Œå³ä¸æ˜¯ç‹¬ç«‹é›†ä½†å…¶ä»»ä½•çœŸå­é›†éƒ½æ˜¯ç‹¬ç«‹é›†ã€‚

---

## ğŸ”§ æ‹Ÿé˜µçš„æ€§è´¨ä¸å®šç†

### ğŸŒ¸ åŸºæœ¬æ€§è´¨

#### æ€§è´¨ 1ï¼šç‹¬ç«‹é›†çš„å•è°ƒæ€§
```
å¦‚æœ A âŠ† B âŠ† Sï¼Œåˆ™ r(A) â‰¤ r(B)
```

#### æ€§è´¨ 2ï¼šæ¬¡æ¨¡æ€§ (Submodularity)
```
å¯¹äºä»»æ„ A, B âŠ† Sï¼š
r(A) + r(B) â‰¥ r(A âˆª B) + r(A âˆ© B)
```

#### æ€§è´¨ 3ï¼šå›è·¯çš„æ€§è´¨
```
å¦‚æœ C æ˜¯å›è·¯ä¸” e âˆˆ Cï¼Œåˆ™ C\{e} æ˜¯ç‹¬ç«‹é›†
```

### ğŸ­ æ‹Ÿé˜µçš„ç­‰ä»·å®šä¹‰

æ‹Ÿé˜µæœ‰å¤šç§ç­‰ä»·å®šä¹‰ï¼Œä»¥ä¸‹æ˜¯åŸºäº**åŸº**çš„å®šä¹‰ï¼š

**å®šä¹‰ 2**ï¼šæ‹Ÿé˜µ `M = (S, B)` ç”±åŸºæ— `B` å®šä¹‰ï¼Œæ»¡è¶³ï¼š
1. `B â‰  âˆ…` (è‡³å°‘æœ‰ä¸€ä¸ªåŸº)
2. å¯¹äºä»»æ„ `Bâ‚, Bâ‚‚ âˆˆ B` å’Œ `x âˆˆ Bâ‚\Bâ‚‚`ï¼Œå­˜åœ¨ `y âˆˆ Bâ‚‚\Bâ‚` ä½¿å¾— `(Bâ‚\{x}) âˆª {y} âˆˆ B`

**å®šç† 2**ï¼šåŸºäºç‹¬ç«‹é›†çš„å®šä¹‰ä¸åŸºäºåŸºçš„å®šä¹‰æ˜¯ç­‰ä»·çš„ã€‚

---

## ğŸš€ è´ªå¿ƒç®—æ³•ä¸æ‹Ÿé˜µ

### ğŸŒŸ è´ªå¿ƒç®—æ³•çš„ä¸€èˆ¬å½¢å¼

å¯¹äºæ‹Ÿé˜µ `M = (S, I)` å’Œæƒé‡å‡½æ•° `w: S â†’ â„`ï¼Œè´ªå¿ƒç®—æ³•å¦‚ä¸‹ï¼š

```python
def greedy_algorithm(S, I, w):
    A = âˆ…
    # æŒ‰æƒé‡é™åºæ’åˆ—å…ƒç´ 
    sort S by w in descending order
    
    for each x in S:
        if A âˆª {x} âˆˆ I:
            A = A âˆª {x}
    
    return A
```

### ğŸ¯ è´ªå¿ƒé€‰æ‹©å®šç†

**å®šç† 3ï¼ˆè´ªå¿ƒé€‰æ‹©å®šç†ï¼‰**ï¼š
å¯¹äºæ‹Ÿé˜µ `M = (S, I)` å’Œæƒé‡å‡½æ•° `w`ï¼Œè´ªå¿ƒç®—æ³•è¿”å›æƒé‡æœ€å¤§çš„åŸºã€‚

**è¯æ˜**ï¼š
è®¾è´ªå¿ƒç®—æ³•è¿”å›åŸº `A = {aâ‚, aâ‚‚, ..., aâ‚–}`ï¼Œå…¶ä¸­ `w(aâ‚) â‰¥ w(aâ‚‚) â‰¥ ... â‰¥ w(aâ‚–)`ã€‚

è®¾ `B = {bâ‚, bâ‚‚, ..., bâ‚–}` æ˜¯ä»»æ„å…¶ä»–åŸºï¼Œå…¶ä¸­ `w(bâ‚) â‰¥ w(bâ‚‚) â‰¥ ... â‰¥ w(bâ‚–)`ã€‚

æˆ‘ä»¬éœ€è¦è¯æ˜ `w(A) â‰¥ w(B)`ã€‚

**åè¯æ³•**ï¼šå‡è®¾ `w(A) < w(B)`ï¼Œåˆ™å­˜åœ¨æœ€å°çš„ `i` ä½¿å¾— `w(aáµ¢) < w(báµ¢)`ã€‚

- ç”±äº `w(aâ‚) â‰¥ ... â‰¥ w(aáµ¢â‚‹â‚) â‰¥ w(aáµ¢)` ä¸” `w(bâ‚) â‰¥ ... â‰¥ w(báµ¢â‚‹â‚) â‰¥ w(báµ¢)`
- ä¸” `w(aâ±¼) â‰¥ w(bâ±¼)` å¯¹æ‰€æœ‰ `j < i`
- å› æ­¤ `w(aáµ¢) < w(báµ¢)`

è€ƒè™‘é›†åˆ `Aáµ¢â‚‹â‚ = {aâ‚, ..., aáµ¢â‚‹â‚}` å’Œ `Báµ¢ = {bâ‚, ..., báµ¢}`ã€‚

ç”±äº `|Aáµ¢â‚‹â‚| = i-1 < i = |Báµ¢|` ä¸”éƒ½æ˜¯ç‹¬ç«‹é›†ï¼Œç”±äº¤æ¢æ€§å­˜åœ¨ `x âˆˆ Báµ¢\Aáµ¢â‚‹â‚` ä½¿å¾— `Aáµ¢â‚‹â‚ âˆª {x} âˆˆ I`ã€‚

ç”±äº `w(x) â‰¥ w(báµ¢) > w(aáµ¢)` ä¸”è´ªå¿ƒç®—æ³•æŒ‰æƒé‡é™åºè€ƒè™‘ï¼Œ`x` åº”è¯¥åœ¨ `aáµ¢` ä¹‹å‰è¢«é€‰æ‹©ï¼Œè¿™ä¸è´ªå¿ƒç®—æ³•çš„æ„é€ çŸ›ç›¾ã€‚

å› æ­¤ `w(A) â‰¥ w(B)`ã€‚

### ğŸ”„ æ‹Ÿé˜µä¸è´ªå¿ƒç®—æ³•çš„åŒå‘å…³ç³»

**å®šç† 4**ï¼šä¸€ä¸ªç»„åˆä¼˜åŒ–é—®é¢˜å¯ä»¥ç”¨è´ªå¿ƒç®—æ³•æ±‚è§£å½“ä¸”ä»…å½“å…¶çº¦æŸç»“æ„å½¢æˆæ‹Ÿé˜µã€‚

**è¯æ˜æ€è·¯**ï¼š
- (â‡’) å¦‚æœè´ªå¿ƒç®—æ³•æ€»æ˜¯æœ€ä¼˜çš„ï¼Œåˆ™çº¦æŸç»“æ„æ»¡è¶³æ‹Ÿé˜µæ€§è´¨
- (â‡) å¦‚æœçº¦æŸç»“æ„æ˜¯æ‹Ÿé˜µï¼Œåˆ™è´ªå¿ƒç®—æ³•æœ€ä¼˜ï¼ˆå®šç†3ï¼‰

---

## ğŸŒ³ æœ€å°ç”Ÿæˆæ ‘çš„æ‹Ÿé˜µè¯æ˜

### ğŸ¯ å›¾æ‹Ÿé˜µ (Graphic Matroid)

å¯¹äºæ— å‘å›¾ `G = (V, E)`ï¼Œå®šä¹‰**å›¾æ‹Ÿé˜µ** `M(G) = (E, I)`ï¼š
```
I = {F âŠ† E : F æ˜¯æ£®æ—}
```

**éªŒè¯æ‹Ÿé˜µæ€§è´¨**ï¼š

#### å…¬ç† 1ï¼šéç©ºæ€§
```
âˆ… æ˜¯æ£®æ— âœ“
```

#### å…¬ç† 2ï¼šé—ä¼ æ€§
```
å¦‚æœ F æ˜¯æ£®æ—ä¸” F' âŠ† Fï¼Œåˆ™ F' ä¹Ÿæ˜¯æ£®æ— âœ“
```

#### å…¬ç† 3ï¼šäº¤æ¢æ€§
```
è®¾ Fâ‚, Fâ‚‚ æ˜¯ä¸¤ä¸ªæ£®æ—ä¸” |Fâ‚| < |Fâ‚‚|
åˆ™å­˜åœ¨ e âˆˆ Fâ‚‚\Fâ‚ ä½¿å¾— Fâ‚ âˆª {e} æ˜¯æ£®æ—
```

**äº¤æ¢æ€§è¯æ˜**ï¼š
- è®¾ Fâ‚ æœ‰ câ‚ ä¸ªè¿é€šåˆ†é‡ï¼ŒFâ‚‚ æœ‰ câ‚‚ ä¸ªè¿é€šåˆ†é‡
- ç”±äº |Fâ‚| < |Fâ‚‚|ï¼Œæœ‰ |V| - câ‚ < |V| - câ‚‚ï¼Œå³ câ‚ > câ‚‚
- å› æ­¤ Fâ‚ æ¯” Fâ‚‚ æœ‰æ›´å¤šè¿é€šåˆ†é‡
- å­˜åœ¨ Fâ‚ ä¸­çš„ä¸¤ä¸ªè¿é€šåˆ†é‡åœ¨ Fâ‚‚ ä¸­æ˜¯è¿é€šçš„
- è¿æ¥è¿™ä¸¤ä¸ªåˆ†é‡çš„è·¯å¾„ä¸­å¿…æœ‰è¾¹ e âˆˆ Fâ‚‚\Fâ‚
- å°† e åŠ å…¥ Fâ‚ ä¸ä¼šäº§ç”Ÿå›è·¯ï¼ˆå› ä¸ºè¿æ¥ä¸åŒåˆ†é‡ï¼‰

### ğŸŒŸ Kruskalç®—æ³•çš„æ‹Ÿé˜µè§£é‡Š

**Kruskalç®—æ³•**ï¼š
```python
def kruskal(G, w):
    sort edges by weight in ascending order
    T = âˆ…
    for each edge e in sorted order:
        if T âˆª {e} forms a forest:
            T = T âˆª {e}
    return T
```

è¿™æ­£æ˜¯å›¾æ‹Ÿé˜µä¸Šçš„è´ªå¿ƒç®—æ³•ï¼

**å®šç† 5**ï¼šKruskalç®—æ³•è¿”å›æœ€å°ç”Ÿæˆæ ‘ã€‚

**è¯æ˜**ï¼š
- å›¾æ‹Ÿé˜µçš„åŸºæ˜¯ç”Ÿæˆæ ‘
- ç”±è´ªå¿ƒé€‰æ‹©å®šç†ï¼ŒæŒ‰æƒé‡å‡åºï¼ˆå³è´Ÿæƒé‡é™åºï¼‰çš„è´ªå¿ƒç®—æ³•è¿”å›æƒé‡æœ€å°çš„åŸº
- å› æ­¤Kruskalç®—æ³•è¿”å›æœ€å°ç”Ÿæˆæ ‘

### ğŸ­ Primç®—æ³•çš„æ‹Ÿé˜µè§£é‡Š

**Primç®—æ³•**ä¹Ÿå¯ä»¥ç”¨æ‹Ÿé˜µç†è®ºè§£é‡Šï¼Œä½†éœ€è¦ä¸åŒçš„æ‹Ÿé˜µï¼š

å¯¹äºèµ·å§‹ç‚¹ `s`ï¼Œå®šä¹‰**Primæ‹Ÿé˜µ** `M_s = (E, I_s)`ï¼š
```
I_s = {F âŠ† E : F ä¸­æ¯ä¸ªè¿é€šåˆ†é‡éƒ½åŒ…å« s}
```

**å®šç† 6**ï¼šPrimç®—æ³•åœ¨Primæ‹Ÿé˜µä¸Šæ‰§è¡Œè´ªå¿ƒç®—æ³•ã€‚

---

## ğŸŒŠ ç½‘ç»œæµä¸æ‹Ÿé˜µ

### ğŸ¯ ç½‘ç»œæµçš„æ‹Ÿé˜µè¡¨ç¤º

ç½‘ç»œæµé—®é¢˜å¯ä»¥é€šè¿‡**æ‹Ÿé˜µäº¤** (Matroid Intersection) æ¥ç†è§£ã€‚

å¯¹äºæœ€å¤§æµé—®é¢˜ï¼Œè€ƒè™‘ä¸¤ä¸ªæ‹Ÿé˜µï¼š
1. **è·¯å¾„æ‹Ÿé˜µ**ï¼šè¡¨ç¤ºä»æºç‚¹åˆ°æ±‡ç‚¹çš„è·¯å¾„çº¦æŸ
2. **å®¹é‡æ‹Ÿé˜µ**ï¼šè¡¨ç¤ºè¾¹å®¹é‡çº¦æŸ

### ğŸŒŸ æ‹Ÿé˜µäº¤é—®é¢˜

**å®šä¹‰**ï¼šç»™å®šä¸¤ä¸ªæ‹Ÿé˜µ `Mâ‚ = (S, Iâ‚)` å’Œ `Mâ‚‚ = (S, Iâ‚‚)`ï¼Œæ±‚ï¼š
```
max{|X| : X âˆˆ Iâ‚ âˆ© Iâ‚‚}
```

**å®šç† 7**ï¼šæ‹Ÿé˜µäº¤é—®é¢˜å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è§£å†³ã€‚

### ğŸ”„ æœ€å¤§æµçš„æ‹Ÿé˜µè§£é‡Š

**Ford-Fulkersonç®—æ³•**å¯ä»¥ç†è§£ä¸ºåœ¨ä¸¤ä¸ªæ‹Ÿé˜µçš„äº¤ä¸­å¯»æ‰¾æœ€å¤§é›†åˆï¼š

1. **è·¯å¾„æ‹Ÿé˜µ**ï¼šæµå¿…é¡»æ²¿ç€ä»æºåˆ°æ±‡çš„è·¯å¾„
2. **å®¹é‡æ‹Ÿé˜µ**ï¼šæµä¸èƒ½è¶…è¿‡è¾¹çš„å®¹é‡

**æ¨å¹¿**ï¼šå¤šå•†å“æµé—®é¢˜ä¹Ÿå¯ä»¥ç”¨æ‹Ÿé˜µäº¤æ¥å»ºæ¨¡ã€‚

---

## ğŸ¨ å…¶ä»–ç»å…¸åº”ç”¨

### ğŸ”¹ ç‹¬ç«‹é›†æ‹Ÿé˜µ

å¯¹äºå›¾ `G = (V, E)`ï¼Œå®šä¹‰**ç‹¬ç«‹é›†æ‹Ÿé˜µ** `M(G) = (V, I)`ï¼š
```
I = {S âŠ† V : S æ˜¯ç‹¬ç«‹é›†}
```

**åº”ç”¨**ï¼šæœ€å¤§æƒç‹¬ç«‹é›†é—®é¢˜ï¼ˆåœ¨æŸäº›ç‰¹æ®Šå›¾ç±»ä¸Šï¼‰

### ğŸ”¹ çº¿æ€§æ‹Ÿé˜µ

å¯¹äºçŸ©é˜µ `A` çš„åˆ—å‘é‡é›†åˆ `S`ï¼Œå®šä¹‰**çº¿æ€§æ‹Ÿé˜µ** `M(A) = (S, I)`ï¼š
```
I = {C âŠ† S : C ä¸­çš„å‘é‡çº¿æ€§æ— å…³}
```

**åº”ç”¨**ï¼šçŸ©é˜µçš„ç§©è®¡ç®—ã€çº¿æ€§è§„åˆ’

### ğŸ”¹ å‡åŒ€æ‹Ÿé˜µ

**å®šä¹‰**ï¼šå‡åŒ€æ‹Ÿé˜µ `U_{n,k} = (S, I)`ï¼Œå…¶ä¸­ `|S| = n`ï¼š
```
I = {T âŠ† S : |T| â‰¤ k}
```

**åº”ç”¨**ï¼šé€‰æ‹©é—®é¢˜ã€èµ„æºåˆ†é…

### ğŸ”¹ åˆ†å‰²æ‹Ÿé˜µ

**å®šä¹‰**ï¼šç»™å®šé›†åˆ `S` çš„åˆ†å‰² `Sâ‚, Sâ‚‚, ..., Sâ‚–` å’Œæ•´æ•° `râ‚, râ‚‚, ..., râ‚–`ï¼š
```
I = {T âŠ† S : |T âˆ© Sáµ¢| â‰¤ ráµ¢ for all i}
```

**åº”ç”¨**ï¼šå¤šçº¦æŸä¼˜åŒ–é—®é¢˜

---

## ğŸ’» ç¼–ç¨‹å®ç°

### ğŸŒ¸ å›¾æ‹Ÿé˜µçš„å®ç°

```cpp
#include <vector>
#include <algorithm>
#include <numeric>
using namespace std;

class GraphMatroid {
private:
    int n, m;
    vector<int> parent, rank;
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
public:
    GraphMatroid(int vertices) : n(vertices) {
        parent.resize(n);
        rank.resize(n, 0);
        iota(parent.begin(), parent.end(), 0);
    }
    
    // æ£€æŸ¥åŠ å…¥è¾¹ (u, v) æ˜¯å¦ä¿æŒæ£®æ—æ€§è´¨
    bool canAdd(int u, int v) {
        return find(u) != find(v);
    }
    
    // æ·»åŠ è¾¹ (u, v)
    void addEdge(int u, int v) {
        int pu = find(u), pv = find(v);
        if (pu == pv) return;
        
        if (rank[pu] < rank[pv]) {
            parent[pu] = pv;
        } else if (rank[pu] > rank[pv]) {
            parent[pv] = pu;
        } else {
            parent[pv] = pu;
            rank[pu]++;
        }
    }
    
    // é‡ç½®æ‹Ÿé˜µçŠ¶æ€
    void reset() {
        iota(parent.begin(), parent.end(), 0);
        fill(rank.begin(), rank.end(), 0);
    }
};

// Kruskalç®—æ³•å®ç°
struct Edge {
    int u, v, weight;
    bool operator<(const Edge& other) const {
        return weight < other.weight;
    }
};

vector<Edge> kruskalMST(int n, vector<Edge>& edges) {
    sort(edges.begin(), edges.end());
    
    GraphMatroid matroid(n);
    vector<Edge> mst;
    
    for (const Edge& e : edges) {
        if (matroid.canAdd(e.u, e.v)) {
            matroid.addEdge(e.u, e.v);
            mst.push_back(e);
            if (mst.size() == n - 1) break;
        }
    }
    
    return mst;
}
```

### ğŸ¯ é€šç”¨æ‹Ÿé˜µè´ªå¿ƒç®—æ³•

```cpp
template<typename T>
class Matroid {
public:
    virtual bool canAdd(const vector<T>& current, const T& element) = 0;
    virtual vector<T> getGroundSet() = 0;
    virtual ~Matroid() = default;
};

template<typename T>
vector<T> greedyMatroid(Matroid<T>& matroid, 
                       function<double(const T&)> weight) {
    vector<T> groundSet = matroid.getGroundSet();
    
    // æŒ‰æƒé‡é™åºæ’åˆ—
    sort(groundSet.begin(), groundSet.end(), 
         [&](const T& a, const T& b) {
             return weight(a) > weight(b);
         });
    
    vector<T> result;
    for (const T& element : groundSet) {
        if (matroid.canAdd(result, element)) {
            result.push_back(element);
        }
    }
    
    return result;
}
```

### ğŸ”„ æ‹Ÿé˜µäº¤ç®—æ³•æ¡†æ¶

```cpp
class MatroidIntersection {
private:
    struct AugmentingPath {
        vector<int> path;
        bool found;
    };
    
    AugmentingPath findAugmentingPath(const vector<int>& current,
                                     Matroid<int>& m1,
                                     Matroid<int>& m2) {
        // å®ç°å¢å¹¿è·¯å¾„æœç´¢
        // è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„ç®—æ³•ï¼Œéœ€è¦æ„å»ºè¾…åŠ©å›¾
        // è¯¦ç»†å®ç°ç•¥
        return {vector<int>(), false};
    }
    
public:
    vector<int> solve(Matroid<int>& m1, Matroid<int>& m2) {
        vector<int> result;
        
        while (true) {
            auto path = findAugmentingPath(result, m1, m2);
            if (!path.found) break;
            
            // æ²¿å¢å¹¿è·¯å¾„æ›´æ–°è§£
            for (int v : path.path) {
                if (find(result.begin(), result.end(), v) == result.end()) {
                    result.push_back(v);
                } else {
                    result.erase(find(result.begin(), result.end(), v));
                }
            }
        }
        
        return result;
    }
};
```

---

## ğŸ­ ç»ƒä¹ é¢˜ä¸åº”ç”¨

### ğŸŒŸ ç»å…¸ç»ƒä¹ é¢˜

1. **æœ€å°ç”Ÿæˆæ ‘å˜å½¢**ï¼š
   - åœ¨ä¿è¯è¿é€šæ€§çš„å‰æä¸‹ï¼Œæœ€å°åŒ–æœ€å¤§è¾¹æƒ
   - å¸¦é¢œè‰²çº¦æŸçš„æœ€å°ç”Ÿæˆæ ‘

2. **æ‹Ÿé˜µäº¤é—®é¢˜**ï¼š
   - äºŒåˆ†å›¾æœ€å¤§åŒ¹é…ï¼ˆä¸¤ä¸ªåˆ†å‰²æ‹Ÿé˜µçš„äº¤ï¼‰
   - æœ‰å‘å›¾çš„å¼ºè¿é€šåˆ†é‡

3. **æ‹Ÿé˜µå¹¶é—®é¢˜**ï¼š
   - ç½‘ç»œå¯é æ€§åˆ†æ
   - å®¹é”™ç³»ç»Ÿè®¾è®¡

### ğŸ¯ å®é™…åº”ç”¨åœºæ™¯

1. **ä»»åŠ¡è°ƒåº¦**ï¼š
   - æ—¶é—´çª—å£çº¦æŸä¸‹çš„ä»»åŠ¡é€‰æ‹©
   - èµ„æºé™åˆ¶ä¸‹çš„æœ€ä¼˜è°ƒåº¦

2. **ç½‘ç»œè®¾è®¡**ï¼š
   - å®¹é”™ç½‘ç»œæ‹“æ‰‘è®¾è®¡
   - å¤šæ’­è·¯ç”±ä¼˜åŒ–

3. **æœºå™¨å­¦ä¹ **ï¼š
   - ç‰¹å¾é€‰æ‹©é—®é¢˜
   - ç¨€ç–è¡¨ç¤ºå­¦ä¹ 

---

## ğŸŒ¸ ãƒ¦ã‚¦ã‚«çš„å­¦ä¹ å»ºè®®

### ğŸ“š å­¦ä¹ è·¯å¾„

1. **åŸºç¡€é˜¶æ®µ**ï¼š
   - ç†è§£æ‹Ÿé˜µçš„ä¸‰ä¸ªå…¬ç†
   - æŒæ¡åŸºæœ¬æ¦‚å¿µï¼ˆåŸºã€ç§©ã€å›è·¯ï¼‰
   - ç»ƒä¹ éªŒè¯ç»™å®šç»“æ„æ˜¯å¦ä¸ºæ‹Ÿé˜µ

2. **åº”ç”¨é˜¶æ®µ**ï¼š
   - å­¦ä¹ å›¾æ‹Ÿé˜µå’Œæœ€å°ç”Ÿæˆæ ‘
   - ç†è§£è´ªå¿ƒç®—æ³•çš„ç†è®ºåŸºç¡€
   - å®ç°åŸºæœ¬çš„æ‹Ÿé˜µç®—æ³•

3. **è¿›é˜¶é˜¶æ®µ**ï¼š
   - ç ”ç©¶æ‹Ÿé˜µäº¤é—®é¢˜
   - æ¢ç´¢å…¶ä»–ç±»å‹çš„æ‹Ÿé˜µ
   - åº”ç”¨åˆ°å®é™…é—®é¢˜ä¸­

### ğŸ¯ å…³é”®ç†è§£ç‚¹

> *"æ‹Ÿé˜µçš„æ ¸å¿ƒæ˜¯'äº¤æ¢æ€§è´¨'ï¼Œå®ƒä¿è¯äº†è´ªå¿ƒé€‰æ‹©çš„æœ€ä¼˜æ€§ã€‚ç†è§£è¿™ä¸€ç‚¹ï¼Œä½ å°±æŒæ¡äº†æ‹Ÿé˜µç†è®ºçš„ç²¾é«“ï¼"*

1. **äº¤æ¢æ€§è´¨**æ˜¯æ‹Ÿé˜µçš„çµé­‚
2. **è´ªå¿ƒç®—æ³•**åœ¨æ‹Ÿé˜µä¸Šæ€»æ˜¯æœ€ä¼˜çš„
3. **æ‹Ÿé˜µäº¤**æ˜¯è®¸å¤šå¤æ‚é—®é¢˜çš„å»ºæ¨¡å·¥å…·
4. **å®é™…åº”ç”¨**ä¸­è¦å–„äºè¯†åˆ«æ‹Ÿé˜µç»“æ„

### ğŸ”§ ç¼–ç¨‹æŠ€å·§

1. **å¹¶æŸ¥é›†**æ˜¯å®ç°å›¾æ‹Ÿé˜µçš„æ ¸å¿ƒå·¥å…·
2. **æ’åº**æ˜¯è´ªå¿ƒç®—æ³•çš„ç¬¬ä¸€æ­¥
3. **å¢å¹¿è·¯å¾„**æ˜¯æ‹Ÿé˜µäº¤ç®—æ³•çš„å…³é”®
4. **æ¨¡æ¿åŒ–**è®¾è®¡ä¾¿äºå¤„ç†ä¸åŒç±»å‹çš„æ‹Ÿé˜µ

---

## ğŸ“– å‚è€ƒèµ„æ–™

1. **Oxley, J.G.** *Matroid Theory*
2. **Welsh, D.J.A.** *Matroid Theory*  
3. **Schrijver, A.** *Combinatorial Optimization*
4. **Korte, B. & Vygen, J.** *Combinatorial Optimization*

---

<div align="center">

### ğŸŒ¸ ç‰¹åˆ«é¸£è°¢

**æ„Ÿè°¢åƒç¦§å¹´ç§‘æŠ€å­¦é™¢æ‰€æœ‰æ•°å­¦çˆ±å¥½è€…ï¼**

> *"æ‹Ÿé˜µç†è®ºè®©æˆ‘ä»¬çœ‹åˆ°äº†è´ªå¿ƒç®—æ³•èƒŒåçš„æ•°å­¦ä¹‹ç¾ï¼Œè¿™æ­£æ˜¯ç®—æ³•ä¸æ•°å­¦å®Œç¾ç»“åˆçš„å…¸èŒƒï¼"*
>
> â€” **ãƒ¦ã‚¦ã‚«**

*ğŸŒ¸ æ•°å­¦çš„ä¸–ç•Œæ°¸è¿œå……æ»¡æƒŠå–œï¼- åƒç¦§å¹´ç§‘æŠ€å­¦é™¢ç®—æ³•ç«èµ›éƒ¨*

</div> 