# ğŸŒ¸ æ›¿ç½ªç¾Šæ ‘è¯¦è§£
## *åƒç¦§å¹´ç§‘æŠ€å­¦é™¢ - ãƒ¦ã‚¦ã‚«æ•°æ®ç»“æ„ä¸“é¢˜*

*"æ›¿ç½ªç¾Šæ ‘ç”¨é‡æ„çš„æ–¹å¼ç»´æŠ¤å¹³è¡¡ï¼Œå½“å­æ ‘ä¸å¹³è¡¡æ—¶æ‰¾åˆ°æ›¿ç½ªç¾Šè¿›è¡Œé‡æ„ï¼"*

---

## ğŸ“š ç›®å½•

1. [æ›¿ç½ªç¾Šæ ‘åŸºæœ¬æ¦‚å¿µ](#æ›¿ç½ªç¾Šæ ‘åŸºæœ¬æ¦‚å¿µ)
2. [å¹³è¡¡æ¡ä»¶ä¸é‡æ„](#å¹³è¡¡æ¡ä»¶ä¸é‡æ„)
3. [æ ¸å¿ƒæ“ä½œè¯¦è§£](#æ ¸å¿ƒæ“ä½œè¯¦è§£)
4. [ç®—æ³•å®ç°](#ç®—æ³•å®ç°)
5. [å¤æ‚åº¦åˆ†æ](#å¤æ‚åº¦åˆ†æ)
6. [ç»å…¸åº”ç”¨](#ç»å…¸åº”ç”¨)
7. [ä¼˜åŒ–æŠ€å·§](#ä¼˜åŒ–æŠ€å·§)

---

## ğŸ¯ æ›¿ç½ªç¾Šæ ‘åŸºæœ¬æ¦‚å¿µ

### å®šä¹‰

**æ›¿ç½ªç¾Šæ ‘ï¼ˆScapegoat Treeï¼‰**æ˜¯ä¸€ç§è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œç”±Igal Galperinå’ŒRonald L. Riveståœ¨1993å¹´å‘æ˜ã€‚å®ƒé€šè¿‡**é‡æ„ä¸å¹³è¡¡å­æ ‘**æ¥ç»´æŠ¤æ•´ä½“å¹³è¡¡æ€§ã€‚

### ğŸŒŸ æ ¸å¿ƒæ€æƒ³

#### å¹³è¡¡ç­–ç•¥ï¼šé‡æ„ä»£æ›¿æ—‹è½¬
```
å½“å‘ç°ä¸å¹³è¡¡æ—¶ï¼Œæ‰¾åˆ°"æ›¿ç½ªç¾Š"èŠ‚ç‚¹
é‡æ„ä»¥æ›¿ç½ªç¾Šä¸ºæ ¹çš„å­æ ‘
```

#### å¹³è¡¡å‚æ•°Î±ï¼ˆalphaï¼‰
- **Î± âˆˆ (0.5, 1)**ï¼šå¹³è¡¡å› å­ï¼Œé€šå¸¸å–0.7æˆ–0.75
- **å¹³è¡¡æ¡ä»¶**ï¼šå¯¹äºä»»æ„èŠ‚ç‚¹ï¼Œå…¶å·¦å³å­æ ‘å¤§å°æ¯”ä¾‹ä¸è¶…è¿‡Î±

### ğŸ” åŸºæœ¬æ€§è´¨

1. **æ‡’æƒ°é‡æ„**ï¼šåªæœ‰åœ¨å¿…è¦æ—¶æ‰é‡æ„
2. **å…¨å±€é‡æ„**ï¼šé‡æ„æ•´ä¸ªå­æ ‘è€Œéå±€éƒ¨è°ƒæ•´
3. **æ— éœ€é¢å¤–ä¿¡æ¯**ï¼šä¸éœ€è¦ç»´æŠ¤é«˜åº¦æˆ–å¹³è¡¡å› å­
4. **æ‘Šè¿˜åˆ†æ**ï¼šå•æ¬¡æ“ä½œå¯èƒ½è€—æ—¶O(n)ï¼Œä½†æ‘Šè¿˜å¤æ‚åº¦O(log n)

---

## ğŸš€ å¹³è¡¡æ¡ä»¶ä¸é‡æ„

### ğŸ­ å¹³è¡¡æ¡ä»¶

#### Î±-å¹³è¡¡æ¡ä»¶
å¯¹äºèŠ‚ç‚¹uï¼Œè®¾size(u)ä¸ºuçš„å­æ ‘å¤§å°ï¼š
```
size(u.left) â‰¤ Î± Ã— size(u)
size(u.right) â‰¤ Î± Ã— size(u)
```

#### é‡æ„è§¦å‘æ¡ä»¶
```
å½“æ’å…¥èŠ‚ç‚¹æ—¶ï¼Œå¦‚æœå­˜åœ¨ç¥–å…ˆèŠ‚ç‚¹væ»¡è¶³ï¼š
size(v.left) > Î± Ã— size(v) æˆ– size(v.right) > Î± Ã— size(v)
åˆ™vå°±æ˜¯"æ›¿ç½ªç¾Š"ï¼Œéœ€è¦é‡æ„ä»¥vä¸ºæ ¹çš„å­æ ‘
```

### ğŸŒ¸ é‡æ„è¿‡ç¨‹

#### 1. ä¸­åºéå†æ”¶é›†èŠ‚ç‚¹
```cpp
void inorderCollect(Node* root, vector<Node*>& nodes) {
    if (!root) return;
    inorderCollect(root->left, nodes);
    nodes.push_back(root);
    inorderCollect(root->right, nodes);
}
```

#### 2. æ„å»ºå®Œå…¨å¹³è¡¡æ ‘
```cpp
Node* buildBalanced(vector<Node*>& nodes, int l, int r) {
    if (l > r) return nullptr;
    
    int mid = (l + r) / 2;
    Node* root = nodes[mid];
    
    root->left = buildBalanced(nodes, l, mid - 1);
    root->right = buildBalanced(nodes, mid + 1, r);
    
    updateSize(root);
    return root;
}
```

#### 3. é‡æ„å†³ç­–æ ‘

```mermaid
graph TD
    A["æ’å…¥èŠ‚ç‚¹"] --> B["å‘ä¸ŠæŸ¥æ‰¾ç¥–å…ˆ"]
    B --> C{"æ˜¯å¦å­˜åœ¨ä¸å¹³è¡¡ç¥–å…ˆï¼Ÿ"}
    C -->|å¦| D["æ’å…¥å®Œæˆ"]
    C -->|æ˜¯| E["æ‰¾åˆ°æ›¿ç½ªç¾ŠèŠ‚ç‚¹"]
    E --> F["ä¸­åºéå†æ”¶é›†èŠ‚ç‚¹"]
    F --> G["é‡æ„ä¸ºå®Œå…¨å¹³è¡¡æ ‘"]
    G --> H["æ’å…¥å®Œæˆ"]
    
    style D fill:#90EE90
    style H fill:#90EE90
    style E fill:#FFB6C1
    style G fill:#87CEEB
```

---

## ğŸ¯ æ ¸å¿ƒæ“ä½œè¯¦è§£

### ğŸŒ¸ æ’å…¥æ“ä½œ

```cpp
bool insert(int key) {
    if (search(key)) return false;  // å·²å­˜åœ¨
    
    Node* newNode = new Node(key);
    root = insertHelper(root, newNode);
    maxSize++;
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ„
    if (newNode->size > alpha * maxSize) {
        Node* scapegoat = findScapegoat(newNode);
        if (scapegoat) {
            rebuildTree(scapegoat);
        }
    }
    
    return true;
}

Node* insertHelper(Node* root, Node* newNode) {
    if (!root) return newNode;
    
    if (newNode->key < root->key) {
        root->left = insertHelper(root->left, newNode);
    } else {
        root->right = insertHelper(root->right, newNode);
    }
    
    updateSize(root);
    return root;
}
```

### ğŸª æŸ¥æ‰¾æ›¿ç½ªç¾Š

```cpp
Node* findScapegoat(Node* node) {
    while (node->parent) {
        Node* parent = node->parent;
        
        // æ£€æŸ¥çˆ¶èŠ‚ç‚¹æ˜¯å¦ä¸ºæ›¿ç½ªç¾Š
        if (node->size > alpha * parent->size) {
            return parent;
        }
        
        node = parent;
    }
    
    return nullptr;  // æ²¡æœ‰æ‰¾åˆ°æ›¿ç½ªç¾Š
}
```

### ğŸ¯ åˆ é™¤æ“ä½œ

```cpp
bool remove(int key) {
    if (!search(key)) return false;
    
    root = removeHelper(root, key);
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦å…¨å±€é‡æ„
    if (currentSize < alpha * maxSize) {
        rebuildTree(root);
        maxSize = currentSize;
    }
    
    return true;
}

Node* removeHelper(Node* root, int key) {
    if (!root) return nullptr;
    
    if (key < root->key) {
        root->left = removeHelper(root->left, key);
    } else if (key > root->key) {
        root->right = removeHelper(root->right, key);
    } else {
        // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
        currentSize--;
        
        if (!root->left && !root->right) {
            delete root;
            return nullptr;
        } else if (!root->left) {
            Node* temp = root->right;
            delete root;
            return temp;
        } else if (!root->right) {
            Node* temp = root->left;
            delete root;
            return temp;
        } else {
            // æ‰¾ä¸­åºåç»§
            Node* successor = findMin(root->right);
            root->key = successor->key;
            root->right = removeHelper(root->right, successor->key);
        }
    }
    
    updateSize(root);
    return root;
}
```

---

## ğŸ’» å®Œæ•´ç®—æ³•å®ç°

### ğŸŒ¸ åŸºç¡€æ›¿ç½ªç¾Šæ ‘

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ScapegoatNode {
    int key, size;
    ScapegoatNode *left, *right, *parent;
    
    ScapegoatNode(int k) : key(k), size(1), left(nullptr), 
                          right(nullptr), parent(nullptr) {}
};

class ScapegoatTree {
private:
    ScapegoatNode* root;
    double alpha;
    int maxSize, currentSize;
    
    void updateSize(ScapegoatNode* node) {
        if (!node) return;
        node->size = 1;
        if (node->left) node->size += node->left->size;
        if (node->right) node->size += node->right->size;
    }
    
    void setParent(ScapegoatNode* child, ScapegoatNode* parent) {
        if (child) child->parent = parent;
    }
    
    void inorderCollect(ScapegoatNode* root, vector<ScapegoatNode*>& nodes) {
        if (!root) return;
        inorderCollect(root->left, nodes);
        nodes.push_back(root);
        inorderCollect(root->right, nodes);
    }
    
    ScapegoatNode* buildBalanced(vector<ScapegoatNode*>& nodes, int l, int r) {
        if (l > r) return nullptr;
        
        int mid = (l + r) / 2;
        ScapegoatNode* root = nodes[mid];
        
        root->left = buildBalanced(nodes, l, mid - 1);
        root->right = buildBalanced(nodes, mid + 1, r);
        
        setParent(root->left, root);
        setParent(root->right, root);
        updateSize(root);
        
        return root;
    }
    
    void rebuildTree(ScapegoatNode*& subtreeRoot) {
        if (!subtreeRoot) return;
        
        vector<ScapegoatNode*> nodes;
        inorderCollect(subtreeRoot, nodes);
        
        subtreeRoot = buildBalanced(nodes, 0, nodes.size() - 1);
        setParent(subtreeRoot, subtreeRoot->parent);
    }
    
    ScapegoatNode* findScapegoat(ScapegoatNode* node) {
        while (node && node->parent) {
            ScapegoatNode* parent = node->parent;
            
            if (node->size > alpha * parent->size) {
                return parent;
            }
            
            node = parent;
        }
        
        return nullptr;
    }
    
    bool needsRebuild(ScapegoatNode* node) {
        if (!node) return false;
        
        int leftSize = node->left ? node->left->size : 0;
        int rightSize = node->right ? node->right->size : 0;
        
        return leftSize > alpha * node->size || rightSize > alpha * node->size;
    }
    
    ScapegoatNode* insertHelper(ScapegoatNode* root, int key, ScapegoatNode* parent = nullptr) {
        if (!root) {
            ScapegoatNode* newNode = new ScapegoatNode(key);
            setParent(newNode, parent);
            return newNode;
        }
        
        if (key < root->key) {
            root->left = insertHelper(root->left, key, root);
        } else if (key > root->key) {
            root->right = insertHelper(root->right, key, root);
        } else {
            return root;  // å·²å­˜åœ¨
        }
        
        updateSize(root);
        return root;
    }
    
    ScapegoatNode* removeHelper(ScapegoatNode* root, int key) {
        if (!root) return nullptr;
        
        if (key < root->key) {
            root->left = removeHelper(root->left, key);
            setParent(root->left, root);
        } else if (key > root->key) {
            root->right = removeHelper(root->right, key);
            setParent(root->right, root);
        } else {
            currentSize--;
            
            if (!root->left && !root->right) {
                delete root;
                return nullptr;
            } else if (!root->left) {
                ScapegoatNode* temp = root->right;
                delete root;
                return temp;
            } else if (!root->right) {
                ScapegoatNode* temp = root->left;
                delete root;
                return temp;
            } else {
                ScapegoatNode* successor = findMin(root->right);
                root->key = successor->key;
                root->right = removeHelper(root->right, successor->key);
                setParent(root->right, root);
            }
        }
        
        updateSize(root);
        return root;
    }
    
    ScapegoatNode* findMin(ScapegoatNode* root) {
        while (root->left) root = root->left;
        return root;
    }
    
    ScapegoatNode* findMax(ScapegoatNode* root) {
        while (root->right) root = root->right;
        return root;
    }
    
    bool searchHelper(ScapegoatNode* root, int key) {
        if (!root) return false;
        
        if (key == root->key) return true;
        else if (key < root->key) return searchHelper(root->left, key);
        else return searchHelper(root->right, key);
    }
    
    int kthHelper(ScapegoatNode* root, int k) {
        if (!root) return -1;
        
        int leftSize = root->left ? root->left->size : 0;
        
        if (k <= leftSize) {
            return kthHelper(root->left, k);
        } else if (k == leftSize + 1) {
            return root->key;
        } else {
            return kthHelper(root->right, k - leftSize - 1);
        }
    }
    
    int getRankHelper(ScapegoatNode* root, int key) {
        if (!root) return 0;
        
        if (key <= root->key) {
            return getRankHelper(root->left, key);
        } else {
            int leftSize = root->left ? root->left->size : 0;
            return leftSize + 1 + getRankHelper(root->right, key);
        }
    }
    
public:
    ScapegoatTree(double a = 0.75) : root(nullptr), alpha(a), maxSize(0), currentSize(0) {}
    
    void insert(int key) {
        if (search(key)) return;  // å·²å­˜åœ¨
        
        root = insertHelper(root, key);
        maxSize++;
        currentSize++;
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ„
        ScapegoatNode* current = root;
        while (current) {
            if (needsRebuild(current)) {
                if (current == root) {
                    rebuildTree(root);
                } else {
                    if (current->parent->left == current) {
                        rebuildTree(current->parent->left);
                    } else {
                        rebuildTree(current->parent->right);
                    }
                }
                break;
            }
            current = current->parent;
        }
    }
    
    void remove(int key) {
        if (!search(key)) return;
        
        root = removeHelper(root, key);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å…¨å±€é‡æ„
        if (currentSize < alpha * maxSize) {
            rebuildTree(root);
            maxSize = currentSize;
        }
    }
    
    bool search(int key) {
        return searchHelper(root, key);
    }
    
    int kth(int k) {
        if (k < 1 || k > currentSize) return -1;
        return kthHelper(root, k);
    }
    
    int getRank(int key) {
        return getRankHelper(root, key) + 1;
    }
    
    int getPredecessor(int key) {
        ScapegoatNode* current = root;
        int result = -1;
        
        while (current) {
            if (current->key < key) {
                result = current->key;
                current = current->right;
            } else {
                current = current->left;
            }
        }
        
        return result;
    }
    
    int getSuccessor(int key) {
        ScapegoatNode* current = root;
        int result = -1;
        
        while (current) {
            if (current->key > key) {
                result = current->key;
                current = current->left;
            } else {
                current = current->right;
            }
        }
        
        return result;
    }
    
    void inorderTraversal() {
        inorderHelper(root);
        cout << endl;
    }
    
    void inorderHelper(ScapegoatNode* root) {
        if (!root) return;
        inorderHelper(root->left);
        cout << root->key << " ";
        inorderHelper(root->right);
    }
    
    int getSize() {
        return currentSize;
    }
    
    bool empty() {
        return currentSize == 0;
    }
    
    // è°ƒè¯•å‡½æ•°
    void printTree() {
        cout << "Tree structure (Î± = " << alpha << "):" << endl;
        printHelper(root, "", true);
        cout << "Current size: " << currentSize << ", Max size: " << maxSize << endl;
    }
    
    void printHelper(ScapegoatNode* node, string indent, bool isLast) {
        if (!node) return;
        
        cout << indent;
        if (isLast) {
            cout << "â””â”€â”€ ";
            indent += "    ";
        } else {
            cout << "â”œâ”€â”€ ";
            indent += "â”‚   ";
        }
        
        cout << node->key << "(size:" << node->size << ")";
        
        // æ£€æŸ¥æ˜¯å¦å¹³è¡¡
        if (needsRebuild(node)) {
            cout << " [UNBALANCED]";
        }
        
        cout << endl;
        
        if (node->left || node->right) {
            if (node->right) {
                printHelper(node->right, indent, !node->left);
            }
            if (node->left) {
                printHelper(node->left, indent, true);
            }
        }
    }
    
    // ç»Ÿè®¡é‡æ„æ¬¡æ•°
    int rebuildCount = 0;
    
    void rebuildTreeWithCount(ScapegoatNode*& subtreeRoot) {
        rebuildCount++;
        rebuildTree(subtreeRoot);
    }
    
    double getAlpha() const {
        return alpha;
    }
    
    void setAlpha(double a) {
        if (a > 0.5 && a < 1.0) {
            alpha = a;
        }
    }
};
```

### ğŸ¯ æ”¯æŒé‡å¤å…ƒç´ çš„æ›¿ç½ªç¾Šæ ‘

```cpp
struct MultiScapegoatNode {
    int key, count, size;
    MultiScapegoatNode *left, *right, *parent;
    
    MultiScapegoatNode(int k) : key(k), count(1), size(1), 
                               left(nullptr), right(nullptr), parent(nullptr) {}
};

class MultiScapegoatTree {
private:
    MultiScapegoatNode* root;
    double alpha;
    int maxSize, currentSize;
    
    void updateSize(MultiScapegoatNode* node) {
        if (!node) return;
        node->size = node->count;
        if (node->left) node->size += node->left->size;
        if (node->right) node->size += node->right->size;
    }
    
    void inorderCollect(MultiScapegoatNode* root, vector<MultiScapegoatNode*>& nodes) {
        if (!root) return;
        inorderCollect(root->left, nodes);
        nodes.push_back(root);
        inorderCollect(root->right, nodes);
    }
    
    MultiScapegoatNode* buildBalanced(vector<MultiScapegoatNode*>& nodes, int l, int r) {
        if (l > r) return nullptr;
        
        int mid = (l + r) / 2;
        MultiScapegoatNode* root = nodes[mid];
        
        root->left = buildBalanced(nodes, l, mid - 1);
        root->right = buildBalanced(nodes, mid + 1, r);
        
        setParent(root->left, root);
        setParent(root->right, root);
        updateSize(root);
        
        return root;
    }
    
    void setParent(MultiScapegoatNode* child, MultiScapegoatNode* parent) {
        if (child) child->parent = parent;
    }
    
    void rebuildTree(MultiScapegoatNode*& subtreeRoot) {
        if (!subtreeRoot) return;
        
        vector<MultiScapegoatNode*> nodes;
        inorderCollect(subtreeRoot, nodes);
        
        subtreeRoot = buildBalanced(nodes, 0, nodes.size() - 1);
        setParent(subtreeRoot, subtreeRoot->parent);
    }
    
    bool needsRebuild(MultiScapegoatNode* node) {
        if (!node) return false;
        
        int leftSize = node->left ? node->left->size : 0;
        int rightSize = node->right ? node->right->size : 0;
        
        return leftSize > alpha * node->size || rightSize > alpha * node->size;
    }
    
    MultiScapegoatNode* insertHelper(MultiScapegoatNode* root, int key, MultiScapegoatNode* parent = nullptr) {
        if (!root) {
            MultiScapegoatNode* newNode = new MultiScapegoatNode(key);
            setParent(newNode, parent);
            return newNode;
        }
        
        if (key < root->key) {
            root->left = insertHelper(root->left, key, root);
        } else if (key > root->key) {
            root->right = insertHelper(root->right, key, root);
        } else {
            root->count++;
            currentSize++;
        }
        
        updateSize(root);
        return root;
    }
    
public:
    MultiScapegoatTree(double a = 0.75) : root(nullptr), alpha(a), maxSize(0), currentSize(0) {}
    
    void insert(int key) {
        bool isNew = !search(key);
        root = insertHelper(root, key);
        
        if (isNew) {
            maxSize++;
            currentSize++;
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ„
            MultiScapegoatNode* current = root;
            while (current) {
                if (needsRebuild(current)) {
                    if (current == root) {
                        rebuildTree(root);
                    } else {
                        if (current->parent->left == current) {
                            rebuildTree(current->parent->left);
                        } else {
                            rebuildTree(current->parent->right);
                        }
                    }
                    break;
                }
                current = current->parent;
            }
        }
    }
    
    void remove(int key) {
        MultiScapegoatNode* node = findNode(root, key);
        if (!node) return;
        
        if (node->count > 1) {
            node->count--;
            currentSize--;
            
            // æ›´æ–°è·¯å¾„ä¸Šçš„size
            MultiScapegoatNode* current = node;
            while (current) {
                updateSize(current);
                current = current->parent;
            }
        } else {
            root = removeHelper(root, key);
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦å…¨å±€é‡æ„
            if (currentSize < alpha * maxSize) {
                rebuildTree(root);
                maxSize = currentSize;
            }
        }
    }
    
    bool search(int key) {
        return findNode(root, key) != nullptr;
    }
    
    int count(int key) {
        MultiScapegoatNode* node = findNode(root, key);
        return node ? node->count : 0;
    }
    
    MultiScapegoatNode* findNode(MultiScapegoatNode* root, int key) {
        if (!root) return nullptr;
        
        if (key == root->key) return root;
        else if (key < root->key) return findNode(root->left, key);
        else return findNode(root->right, key);
    }
    
    MultiScapegoatNode* removeHelper(MultiScapegoatNode* root, int key) {
        if (!root) return nullptr;
        
        if (key < root->key) {
            root->left = removeHelper(root->left, key);
            setParent(root->left, root);
        } else if (key > root->key) {
            root->right = removeHelper(root->right, key);
            setParent(root->right, root);
        } else {
            currentSize -= root->count;
            
            if (!root->left && !root->right) {
                delete root;
                return nullptr;
            } else if (!root->left) {
                MultiScapegoatNode* temp = root->right;
                delete root;
                return temp;
            } else if (!root->right) {
                MultiScapegoatNode* temp = root->left;
                delete root;
                return temp;
            } else {
                MultiScapegoatNode* successor = findMin(root->right);
                root->key = successor->key;
                root->count = successor->count;
                successor->count = 1;  // é¿å…é‡å¤å‡å°‘
                root->right = removeHelper(root->right, successor->key);
                setParent(root->right, root);
            }
        }
        
        updateSize(root);
        return root;
    }
    
    MultiScapegoatNode* findMin(MultiScapegoatNode* root) {
        while (root->left) root = root->left;
        return root;
    }
};
```

### ğŸª åŠ¨æ€Î±å€¼çš„æ›¿ç½ªç¾Šæ ‘

```cpp
class AdaptiveScapegoatTree {
private:
    ScapegoatTree tree;
    double baseAlpha;
    int operationCount;
    int rebuildCount;
    
    void adjustAlpha() {
        operationCount++;
        
        if (operationCount % 100 == 0) {  // æ¯100æ¬¡æ“ä½œè°ƒæ•´ä¸€æ¬¡
            double rebuildRatio = (double)rebuildCount / operationCount;
            
            if (rebuildRatio > 0.1) {  // é‡æ„å¤ªé¢‘ç¹ï¼Œå¢åŠ Î±
                tree.setAlpha(min(0.9, tree.getAlpha() + 0.05));
            } else if (rebuildRatio < 0.01) {  // é‡æ„å¤ªå°‘ï¼Œå‡å°‘Î±
                tree.setAlpha(max(0.6, tree.getAlpha() - 0.05));
            }
        }
    }
    
public:
    AdaptiveScapegoatTree(double a = 0.75) : tree(a), baseAlpha(a), 
                                            operationCount(0), rebuildCount(0) {}
    
    void insert(int key) {
        int oldRebuildCount = tree.rebuildCount;
        tree.insert(key);
        
        if (tree.rebuildCount > oldRebuildCount) {
            rebuildCount++;
        }
        
        adjustAlpha();
    }
    
    void remove(int key) {
        int oldRebuildCount = tree.rebuildCount;
        tree.remove(key);
        
        if (tree.rebuildCount > oldRebuildCount) {
            rebuildCount++;
        }
        
        adjustAlpha();
    }
    
    bool search(int key) {
        return tree.search(key);
    }
    
    void printStats() {
        cout << "Operations: " << operationCount << endl;
        cout << "Rebuilds: " << rebuildCount << endl;
        cout << "Current Î±: " << tree.getAlpha() << endl;
        cout << "Rebuild ratio: " << (double)rebuildCount / operationCount << endl;
    }
};
```

---

## âš¡ å¤æ‚åº¦åˆ†æ

### æ—¶é—´å¤æ‚åº¦

| æ“ä½œ | æœ€åæƒ…å†µ | å¹³æ‘Šå¤æ‚åº¦ | è¯´æ˜ |
|------|----------|------------|------|
| **æŸ¥æ‰¾** | O(log n) | O(log n) | æ·±åº¦å§‹ç»ˆä¸ºO(log n) |
| **æ’å…¥** | O(n) | O(log n) | é‡æ„æ—¶éœ€è¦O(n) |
| **åˆ é™¤** | O(n) | O(log n) | é‡æ„æ—¶éœ€è¦O(n) |
| **é‡æ„** | O(n) | - | å•æ¬¡é‡æ„æˆæœ¬ |

### ğŸ¯ å¹³æ‘Šåˆ†æ

#### åŠ¿å‡½æ•°æ–¹æ³•
å®šä¹‰åŠ¿å‡½æ•° Î¦(T) = ä¸å¹³è¡¡èŠ‚ç‚¹æ•°é‡
- æ¯æ¬¡æ’å…¥å¢åŠ åŠ¿èƒ½
- é‡æ„æ—¶é‡Šæ”¾å¤§é‡åŠ¿èƒ½
- æ‘Šè¿˜æˆæœ¬ä¸ºO(log n)

#### é‡æ„é¢‘ç‡
- æ’å…¥nä¸ªå…ƒç´ æœ€å¤šé‡æ„O(n)æ¬¡
- æ¯ä¸ªèŠ‚ç‚¹å¹³å‡è¢«é‡æ„O(log n)æ¬¡
- æ€»æ‘Šè¿˜æˆæœ¬ä¸ºO(n log n)

### ğŸŒ¸ Î±å€¼çš„é€‰æ‹©

#### ç†è®ºåˆ†æ
- **Î± = 0.5**ï¼šå®Œå…¨å¹³è¡¡ï¼Œä½†é‡æ„è¿‡äºé¢‘ç¹
- **Î± = 1.0**ï¼šæ°¸ä¸é‡æ„ï¼Œé€€åŒ–ä¸ºé“¾è¡¨
- **Î± = 0.7-0.8**ï¼šå®è·µä¸­çš„æœ€ä½³é€‰æ‹©

#### æ€§èƒ½å¯¹æ¯”

| Î±å€¼ | æ·±åº¦ä¿è¯ | é‡æ„é¢‘ç‡ | æ¨èåœºæ™¯ |
|-----|----------|----------|----------|
| **0.6** | æ›´å¹³è¡¡ | è¾ƒé¢‘ç¹ | æŸ¥æ‰¾å¯†é›†å‹ |
| **0.75** | å¹³è¡¡ | é€‚ä¸­ | é€šç”¨åœºæ™¯ |
| **0.9** | è¾ƒæ¾æ•£ | è¾ƒå°‘ | æ’å…¥å¯†é›†å‹ |

### ç©ºé—´å¤æ‚åº¦
- **åŸºæœ¬ç»“æ„**ï¼šO(n)
- **é‡æ„ä¸´æ—¶ç©ºé—´**ï¼šO(n)

---

## ğŸ† ç»å…¸åº”ç”¨

### åº”ç”¨åœºæ™¯

#### 1. æ™®é€šå¹³è¡¡æ ‘
```cpp
void solveBST() {
    ScapegoatTree tree(0.75);
    int q;
    cin >> q;
    
    while (q--) {
        int op;
        cin >> op;
        
        switch (op) {
            case 1: {  // æ’å…¥
                int x;
                cin >> x;
                tree.insert(x);
                break;
            }
            case 2: {  // åˆ é™¤
                int x;
                cin >> x;
                tree.remove(x);
                break;
            }
            case 3: {  // æŸ¥è¯¢æ’å
                int x;
                cin >> x;
                cout << tree.getRank(x) << "\n";
                break;
            }
            case 4: {  // æŸ¥è¯¢ç¬¬kå°
                int k;
                cin >> k;
                cout << tree.kth(k) << "\n";
                break;
            }
            case 5: {  // å‰é©±
                int x;
                cin >> x;
                cout << tree.getPredecessor(x) << "\n";
                break;
            }
            case 6: {  // åç»§
                int x;
                cin >> x;
                cout << tree.getSuccessor(x) << "\n";
                break;
            }
        }
    }
}
```

#### 2. åŠ¨æ€ç¬¬kå¤§
```cpp
class DynamicKth {
private:
    ScapegoatTree tree;
    
public:
    void insert(int x) {
        tree.insert(x);
    }
    
    void remove(int x) {
        tree.remove(x);
    }
    
    int kth(int k) {
        return tree.kth(k);
    }
    
    int count() {
        return tree.getSize();
    }
    
    vector<int> getTopK(int k) {
        vector<int> result;
        for (int i = tree.getSize() - k + 1; i <= tree.getSize(); i++) {
            result.push_back(tree.kth(i));
        }
        return result;
    }
};
```

#### 3. åŒºé—´æŸ¥è¯¢
```cpp
class RangeQuery {
private:
    ScapegoatTree tree;
    
public:
    void insert(int x) {
        tree.insert(x);
    }
    
    int countInRange(int l, int r) {
        int leftRank = tree.getRank(l);
        int rightRank = tree.getRank(r + 1);
        return rightRank - leftRank;
    }
    
    vector<int> getInRange(int l, int r) {
        vector<int> result;
        int leftRank = tree.getRank(l);
        int rightRank = tree.getRank(r + 1);
        
        for (int i = leftRank; i < rightRank; i++) {
            result.push_back(tree.kth(i));
        }
        
        return result;
    }
};
```

### ç»å…¸ä¾‹é¢˜

#### ä¾‹é¢˜1ï¼šæ´›è°·P3369 - æ™®é€šå¹³è¡¡æ ‘
```cpp
int main() {
    ScapegoatTree tree;
    int n;
    cin >> n;
    
    while (n--) {
        int op, x;
        cin >> op >> x;
        
        switch (op) {
            case 1: tree.insert(x); break;
            case 2: tree.remove(x); break;
            case 3: cout << tree.getRank(x) << "\n"; break;
            case 4: cout << tree.kth(x) << "\n"; break;
            case 5: cout << tree.getPredecessor(x) << "\n"; break;
            case 6: cout << tree.getSuccessor(x) << "\n"; break;
        }
    }
    
    return 0;
}
```

#### ä¾‹é¢˜2ï¼šåŠ¨æ€é€†åºå¯¹
```cpp
class DynamicInversions {
private:
    ScapegoatTree tree;
    long long inversions;
    
public:
    DynamicInversions() : inversions(0) {}
    
    void insert(int x) {
        // è®¡ç®—æ¯”xå¤§çš„æ•°çš„ä¸ªæ•°
        int total = tree.getSize();
        int rank = tree.getRank(x);
        inversions += total - rank + 1;
        
        tree.insert(x);
    }
    
    void remove(int x) {
        int total = tree.getSize();
        int rank = tree.getRank(x);
        inversions -= total - rank;
        
        tree.remove(x);
    }
    
    long long getInversions() {
        return inversions;
    }
};
```

#### ä¾‹é¢˜3ï¼šæ»‘åŠ¨çª—å£ç¬¬kå¤§
```cpp
class SlidingWindowKth {
private:
    ScapegoatTree tree;
    queue<int> window;
    int windowSize;
    
public:
    SlidingWindowKth(int k) : windowSize(k) {}
    
    int addAndGetKth(int x, int k) {
        window.push(x);
        tree.insert(x);
        
        if (window.size() > windowSize) {
            int removed = window.front();
            window.pop();
            tree.remove(removed);
        }
        
        return tree.kth(k);
    }
    
    vector<int> processArray(vector<int>& arr, int k) {
        vector<int> result;
        
        for (int x : arr) {
            int kth = addAndGetKth(x, k);
            if (window.size() == windowSize) {
                result.push_back(kth);
            }
        }
        
        return result;
    }
};
```

---

## ğŸ’¡ ä¼˜åŒ–æŠ€å·§

### å®ç°ä¼˜åŒ–

#### 1. å»¶è¿Ÿé‡æ„
```cpp
class LazyScapegoatTree {
private:
    ScapegoatTree tree;
    int operationsSinceRebuild;
    const int rebuildThreshold = 100;
    
public:
    void insert(int key) {
        tree.insert(key);
        operationsSinceRebuild++;
        
        if (operationsSinceRebuild >= rebuildThreshold) {
            // æ‰§è¡Œå…¨å±€é‡æ„
            tree.rebuildTree(tree.root);
            operationsSinceRebuild = 0;
        }
    }
    
    void remove(int key) {
        tree.remove(key);
        operationsSinceRebuild++;
        
        if (operationsSinceRebuild >= rebuildThreshold) {
            tree.rebuildTree(tree.root);
            operationsSinceRebuild = 0;
        }
    }
};
```

#### 2. æ‰¹é‡é‡æ„
```cpp
class BatchRebuildTree {
private:
    ScapegoatTree tree;
    vector<int> pendingInserts;
    vector<int> pendingRemoves;
    const int batchSize = 50;
    
public:
    void insert(int key) {
        pendingInserts.push_back(key);
        
        if (pendingInserts.size() >= batchSize) {
            processBatch();
        }
    }
    
    void remove(int key) {
        pendingRemoves.push_back(key);
        
        if (pendingRemoves.size() >= batchSize) {
            processBatch();
        }
    }
    
private:
    void processBatch() {
        // æ”¶é›†æ‰€æœ‰ç°æœ‰èŠ‚ç‚¹
        vector<int> allNodes;
        tree.getAllNodes(allNodes);
        
        // åˆå¹¶å¾…å¤„ç†çš„æ“ä½œ
        for (int x : pendingInserts) {
            allNodes.push_back(x);
        }
        
        for (int x : pendingRemoves) {
            allNodes.erase(find(allNodes.begin(), allNodes.end(), x));
        }
        
        // é‡æ„æ•´ä¸ªæ ‘
        tree.buildFromSorted(allNodes);
        
        pendingInserts.clear();
        pendingRemoves.clear();
    }
};
```

#### 3. å†…å­˜ä¼˜åŒ–
```cpp
class MemoryOptimizedScapegoat {
private:
    struct CompactNode {
        int key;
        short size;  // ä½¿ç”¨shortèŠ‚çœå†…å­˜
        CompactNode* left;
        CompactNode* right;
        
        CompactNode(int k) : key(k), size(1), left(nullptr), right(nullptr) {}
    };
    
    CompactNode* root;
    vector<CompactNode*> freeList;  // å†…å­˜æ± 
    
public:
    CompactNode* newNode(int key) {
        if (!freeList.empty()) {
            CompactNode* node = freeList.back();
            freeList.pop_back();
            node->key = key;
            node->size = 1;
            node->left = node->right = nullptr;
            return node;
        }
        
        return new CompactNode(key);
    }
    
    void deleteNode(CompactNode* node) {
        if (node) {
            freeList.push_back(node);
        }
    }
};
```

### åº”ç”¨ä¼˜åŒ–

#### 1. è‡ªé€‚åº”Î±å€¼
```cpp
class AdaptiveAlpha {
private:
    double currentAlpha;
    int queryCount;
    int insertCount;
    double queryRatio;
    
public:
    AdaptiveAlpha() : currentAlpha(0.75), queryCount(0), insertCount(0) {}
    
    void recordQuery() {
        queryCount++;
        updateAlpha();
    }
    
    void recordInsert() {
        insertCount++;
        updateAlpha();
    }
    
private:
    void updateAlpha() {
        if (queryCount + insertCount > 100) {
            queryRatio = (double)queryCount / (queryCount + insertCount);
            
            if (queryRatio > 0.8) {
                // æŸ¥è¯¢å¯†é›†ï¼Œä½¿ç”¨è¾ƒå°çš„Î±
                currentAlpha = 0.6;
            } else if (queryRatio < 0.3) {
                // æ’å…¥å¯†é›†ï¼Œä½¿ç”¨è¾ƒå¤§çš„Î±
                currentAlpha = 0.9;
            } else {
                // å¹³è¡¡ä½¿ç”¨
                currentAlpha = 0.75;
            }
        }
    }
    
public:
    double getAlpha() const {
        return currentAlpha;
    }
};
```

#### 2. ç»Ÿè®¡ä¿¡æ¯æ”¶é›†
```cpp
class StatisticsScapegoat {
private:
    ScapegoatTree tree;
    
public:
    struct Statistics {
        int totalOperations;
        int totalRebuilds;
        int maxDepth;
        double avgDepth;
        int currentSize;
        
        void print() {
            cout << "=== Scapegoat Tree Statistics ===" << endl;
            cout << "Total operations: " << totalOperations << endl;
            cout << "Total rebuilds: " << totalRebuilds << endl;
            cout << "Rebuild ratio: " << (double)totalRebuilds / totalOperations << endl;
            cout << "Max depth: " << maxDepth << endl;
            cout << "Average depth: " << avgDepth << endl;
            cout << "Current size: " << currentSize << endl;
        }
    };
    
    Statistics getStatistics() {
        Statistics stats;
        stats.totalOperations = tree.operationCount;
        stats.totalRebuilds = tree.rebuildCount;
        stats.maxDepth = tree.getMaxDepth();
        stats.avgDepth = tree.getAvgDepth();
        stats.currentSize = tree.getSize();
        return stats;
    }
};
```

---

## ğŸ“ å­¦ä¹ å»ºè®®

### ğŸŒŸ æŒæ¡è¦ç‚¹

1. **ç†è§£å¹³è¡¡ç­–ç•¥**ï¼šé‡æ„vsæ—‹è½¬çš„åŒºåˆ«å’Œä¼˜åŠ¿
2. **æŒæ¡Î±å€¼é€‰æ‹©**ï¼šæ ¹æ®åº”ç”¨åœºæ™¯é€‰æ‹©åˆé€‚çš„Î±
3. **åˆ†ææ‘Šè¿˜å¤æ‚åº¦**ï¼šç†è§£ä¸ºä»€ä¹ˆå¹³æ‘Šæ—¶é—´ä¸ºO(log n)
4. **å®ç°ç»†èŠ‚**ï¼šæ³¨æ„çˆ¶æŒ‡é’ˆç»´æŠ¤å’Œsizeæ›´æ–°

### ğŸ“š æ¨èç»ƒä¹ é¢˜

#### å…¥é—¨çº§
1. **æ´›è°·P3369** - æ™®é€šå¹³è¡¡æ ‘
2. **æ´›è°·P1110** - æŠ¥è¡¨ç»Ÿè®¡
3. **HDU1394** - Minimum Inversion Number

#### è¿›é˜¶çº§
1. **æ´›è°·P2234** - è¥ä¸šé¢ç»Ÿè®¡
2. **æ´›è°·P1637** - ä¸‰å…ƒä¸Šå‡å­åºåˆ—
3. **CF785E** - Anton and Permutation

#### æŒ‘æˆ˜çº§
1. **BZOJ1901** - Zju2112 Dynamic Rankings
2. **SPOJ MKTHNUM** - K-th Number
3. **CF1288F** - Red-Blue Graph

### ğŸš€ è¿›é˜¶æ–¹å‘

1. **æƒé‡æ›¿ç½ªç¾Šæ ‘**ï¼šæ”¯æŒåŠ æƒæ“ä½œ
2. **å¯æŒä¹…åŒ–æ›¿ç½ªç¾Šæ ‘**ï¼šæ”¯æŒå†å²ç‰ˆæœ¬
3. **å¹¶è¡Œæ›¿ç½ªç¾Šæ ‘**ï¼šæ”¯æŒå¹¶å‘æ“ä½œ
4. **å¤–å­˜æ›¿ç½ªç¾Šæ ‘**ï¼šå¤„ç†å¤§è§„æ¨¡æ•°æ®

---

<div align="center">

### ğŸŒ¸ ç‰¹åˆ«é¸£è°¢

**æ„Ÿè°¢åƒç¦§å¹´ç§‘æŠ€å­¦é™¢æ•°æ®ç»“æ„ç ”ç©¶å°ç»„ï¼**

> *"æ›¿ç½ªç¾Šæ ‘å‘Šè¯‰æˆ‘ä»¬ï¼Œæœ‰æ—¶å€™è§£å†³é—®é¢˜çš„æœ€å¥½æ–¹æ³•å°±æ˜¯é‡æ–°å¼€å§‹ã€‚å½“å±€éƒ¨è°ƒæ•´å˜å¾—å¤æ‚æ—¶ï¼Œä¸å¦‚å…¨å±€é‡æ„æ¥å¾—ç®€å•ç›´æ¥ï¼"*
>
> â€” **ãƒ¦ã‚¦ã‚«**

*ğŸŒ¸ åœ¨æ•°æ®ç»“æ„çš„ä¸–ç•Œé‡Œï¼Œæ›¿ç½ªç¾Šæ ‘ä»¥å…¶ç‹¬ç‰¹çš„é‡æ„æ€æƒ³å±•ç°äº†ç®—æ³•è®¾è®¡çš„å¦ä¸€ç§æ™ºæ…§ï¼*

</div> 