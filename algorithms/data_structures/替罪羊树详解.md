# ğŸ¯ æ›¿ç½ªç¾Šæ ‘ - é‡æ„çš„è‰ºæœ¯
## *åƒç¦§å¹´ç§‘æŠ€å­¦é™¢ - ãƒ¦ã‚ºè€å¸ˆçš„æ•°æ®ç»“æ„è¯¾*

*"å½“æ ‘å˜å¾—ä¸å¹³è¡¡æ—¶ï¼Œæˆ‘ä»¬ä¸æ˜¯è°ƒæ•´ï¼Œè€Œæ˜¯é‡å»ºï¼å°±åƒæ¸¸æˆä¸­çš„åœ°å›¾é‡æ„ï¼Œç®€å•ç²—æš´åˆæœ‰æ•ˆï¼"*

---

## ğŸª å¼€å§‹ä¹‹å‰ - ä»€ä¹ˆæ˜¯æ›¿ç½ªç¾Šæ ‘ï¼Ÿ

### ğŸŒŸ æœ€ç®€å•çš„ç†è§£

æƒ³è±¡ä½ æ˜¯ä¸€ä¸ª**æ•´ç†æˆ¿é—´çš„æ‡’äºº**ï¼š
- ğŸ  å¹³æ—¶æˆ¿é—´ä¹±äº†ä¸ç®¡
- ğŸ“š ä¹¦æ¶å€’äº†ä¸æ‰¶
- ğŸ§¹ åªæœ‰å½“ä¹±åˆ°å—ä¸äº†æ—¶ï¼Œæ‰æ¥ä¸ªå¤§æ‰«é™¤
- âœ¨ å¤§æ‰«é™¤åï¼Œæˆ¿é—´å˜å¾—äº•äº•æœ‰æ¡

**æ›¿ç½ªç¾Šæ ‘å°±æ˜¯è¿™æ ·çš„"æ‡’äººæ¸…ç†æ³•"ï¼**

### ğŸ¯ æ ¸å¿ƒæ€æƒ³

```
å¹³æ—¶ä¸ç®¡å¹³è¡¡ â†’ å¤±è¡¡ä¸¥é‡æ—¶ â†’ æ‰¾åˆ°ç½ªé­ç¥¸é¦– â†’ é‡æ„æ•´ä¸ªå­æ ‘
```

### ğŸ® æ¸¸æˆåŒ–ç†è§£

å°±åƒç©**åŸå¸‚å»ºè®¾æ¸¸æˆ**ï¼š
- ğŸ—ï¸ å¹³æ—¶éšä¾¿å»ºæˆ¿å­
- ğŸ“ˆ äººå£å¢é•¿ï¼Œäº¤é€šæ‹¥å µ
- ğŸ”¥ å½“æ‹¥å µä¸¥é‡æ—¶ï¼Œæ‹†æ‰é‡å»º
- ğŸ é‡å»ºåäº¤é€šé¡ºç•…

---

## ğŸ“– ç¬¬ä¸€ç« ï¼šä¸ºä»€ä¹ˆå«"æ›¿ç½ªç¾Š"ï¼Ÿ

### ğŸ­ æ›¿ç½ªç¾Šçš„æ•…äº‹

å¤ä»£æœ‰ä¸ªä¹ ä¿—ï¼š
- ğŸ‘ æ‘å­é‡Œå‡ºäº†é—®é¢˜ï¼Œæ‰¾ä¸€åªç¾ŠèƒŒé”…
- ğŸ”¥ æŠŠæ‰€æœ‰ç½ªè´£éƒ½æ¨ç»™è¿™åªç¾Š
- ğŸŒŸ ç„¶åé‡æ–°å¼€å§‹ï¼Œä¸€åˆ‡éƒ½å¥½äº†

### ğŸŒ¸ æ•°æ®ç»“æ„ä¸­çš„æ›¿ç½ªç¾Š

**åœ¨æ›¿ç½ªç¾Šæ ‘ä¸­ï¼š**
- ğŸŒ³ æ ‘å˜å¾—ä¸å¹³è¡¡äº†
- ğŸ” æ‰¾åˆ°é‚£ä¸ª"ç½ªé­ç¥¸é¦–"çš„èŠ‚ç‚¹
- ğŸ’¥ é‡æ„è¿™ä¸ªèŠ‚ç‚¹çš„æ•´ä¸ªå­æ ‘
- âœ¨ é‡æ„åï¼Œå­æ ‘å˜å¾—å®Œç¾å¹³è¡¡

### ğŸ“Š ä¸¾ä¸ªä¾‹å­

**ä¸å¹³è¡¡çš„æ ‘ï¼š**
```
    10
   /  \
  5    15
 /    /  \
1    12   20
    /     /
   11    18
         /
        17
```

**å³å­æ ‘å¤ªé«˜äº†ï¼15å°±æ˜¯"æ›¿ç½ªç¾Š"ï¼**

**é‡æ„15çš„å­æ ‘åï¼š**
```
    10
   /  \
  5    15
 /    /  \
1    12   18
    /    / \
   11   17  20
```

---

## ğŸš€ ç¬¬äºŒç« ï¼šä»€ä¹ˆæ—¶å€™éœ€è¦é‡æ„ï¼Ÿ

### ğŸ¯ å¹³è¡¡æ¡ä»¶ï¼šÎ±å€¼

**Î±å€¼å°±åƒæ¸¸æˆä¸­çš„"æ‹¥å µåº¦"ï¼š**
- ğŸŸ¢ Î± = 0.5ï¼šè¦æ±‚ç»å¯¹å¹³è¡¡ï¼ˆå¤ªä¸¥æ ¼ï¼‰
- ğŸŸ¡ Î± = 0.7ï¼šæ¯”è¾ƒå¹³è¡¡ï¼ˆåˆç†ï¼‰
- ğŸ”´ Î± = 0.9ï¼šåŸºæœ¬ä¸ç®¡ï¼ˆå¤ªæ¾ï¼‰

**é€šå¸¸æˆ‘ä»¬é€‰æ‹©Î± = 0.75**

### ğŸŒŸ åˆ¤æ–­æ ‡å‡†

å¯¹äºä»»æ„èŠ‚ç‚¹ï¼Œå¦‚æœï¼š
```
å·¦å­æ ‘å¤§å° > Î± Ã— æ€»å¤§å° æˆ– å³å­æ ‘å¤§å° > Î± Ã— æ€»å¤§å°
```
é‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹å°±éœ€è¦é‡æ„ï¼

### ğŸ“Š å…·ä½“ä¾‹å­

**å‡è®¾Î± = 0.75ï¼š**
```
    èŠ‚ç‚¹A (æ€»å¤§å°=10)
   /          \
å·¦å­æ ‘(å¤§å°=8)  å³å­æ ‘(å¤§å°=2)
```

**æ£€æŸ¥ï¼š**
- å·¦å­æ ‘ï¼š8 > 0.75 Ã— 10 = 7.5 âœ“ éœ€è¦é‡æ„ï¼
- å³å­æ ‘ï¼š2 > 0.75 Ã— 10 = 7.5 âœ— ä¸éœ€è¦é‡æ„

**èŠ‚ç‚¹Aå°±æ˜¯"æ›¿ç½ªç¾Š"ï¼**

---

## ğŸª ç¬¬ä¸‰ç« ï¼šé‡æ„çš„æ­¥éª¤

### ğŸŒ¸ é‡æ„ä¸‰éƒ¨æ›²

1. **æ”¶é›†èŠ‚ç‚¹** - ä¸­åºéå†æ”¶é›†æ‰€æœ‰èŠ‚ç‚¹
2. **æ’åºæ•´ç†** - æŒ‰ç…§å¤§å°æ’åºï¼ˆå…¶å®å·²ç»æœ‰åºï¼‰
3. **é‡æ–°æ„å»º** - æ„å»ºå®Œç¾å¹³è¡¡çš„å­æ ‘

### ğŸ¯ å…·ä½“æ¼”ç¤º

**åŸå§‹ä¸å¹³è¡¡å­æ ‘ï¼š**
```
    15
   /  \
  12   20
 /    /
11   18
    /
   17
```

**æ­¥éª¤1ï¼šæ”¶é›†èŠ‚ç‚¹**
```
ä¸­åºéå†ï¼š11, 12, 15, 17, 18, 20
```

**æ­¥éª¤2ï¼šæ„å»ºå¹³è¡¡æ ‘**
```
æ•°ç»„ï¼š[11, 12, 15, 17, 18, 20]
é€‰æ‹©ä¸­ä½æ•°ï¼š15 (ç´¢å¼•2)

    15
   /  \
  12   18
 /    / \
11   17  20
```

**å®Œç¾å¹³è¡¡ï¼**

---

## ğŸ’» ç¬¬å››ç« ï¼šç®€å•å®ç°

### ğŸŒ¸ åŸºç¡€ç‰ˆæœ¬

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Node {
    int key;
    int size;
    Node* left;
    Node* right;
    
    Node(int k) : key(k), size(1), left(nullptr), right(nullptr) {}
};

class ScapegoatTree {
private:
    Node* root;
    double alpha;
    vector<Node*> nodes;  // ç”¨äºé‡æ„æ—¶æ”¶é›†èŠ‚ç‚¹
    
    // æ›´æ–°èŠ‚ç‚¹å¤§å°
    void updateSize(Node* node) {
        if (!node) return;
        node->size = 1;
        if (node->left) node->size += node->left->size;
        if (node->right) node->size += node->right->size;
    }
    
    // åˆ¤æ–­æ˜¯å¦éœ€è¦é‡æ„
    bool needRebuild(Node* node) {
        if (!node) return false;
        
        int leftSize = node->left ? node->left->size : 0;
        int rightSize = node->right ? node->right->size : 0;
        
        return leftSize > alpha * node->size || 
               rightSize > alpha * node->size;
    }
    
    // ä¸­åºéå†æ”¶é›†èŠ‚ç‚¹
    void collectNodes(Node* node) {
        if (!node) return;
        collectNodes(node->left);
        nodes.push_back(node);
        collectNodes(node->right);
    }
    
    // ä»æœ‰åºæ•°ç»„æ„å»ºå¹³è¡¡æ ‘
    Node* buildBalanced(int left, int right) {
        if (left > right) return nullptr;
        
        int mid = (left + right) / 2;
        Node* node = nodes[mid];
        
        node->left = buildBalanced(left, mid - 1);
        node->right = buildBalanced(mid + 1, right);
        
        updateSize(node);
        return node;
    }
    
    // é‡æ„å­æ ‘
    Node* rebuild(Node* node) {
        if (!node) return nullptr;
        
        nodes.clear();
        collectNodes(node);
        
        return buildBalanced(0, nodes.size() - 1);
    }
    
    // æ’å…¥èŠ‚ç‚¹
    Node* insertHelper(Node* node, int key) {
        if (!node) {
            return new Node(key);
        }
        
        if (key < node->key) {
            node->left = insertHelper(node->left, key);
        } else if (key > node->key) {
            node->right = insertHelper(node->right, key);
        } else {
            return node;  // å·²å­˜åœ¨
        }
        
        updateSize(node);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ„
        if (needRebuild(node)) {
            return rebuild(node);
        }
        
        return node;
    }
    
    // æŸ¥æ‰¾èŠ‚ç‚¹
    bool searchHelper(Node* node, int key) {
        if (!node) return false;
        
        if (key == node->key) return true;
        else if (key < node->key) return searchHelper(node->left, key);
        else return searchHelper(node->right, key);
    }
    
    // åˆ é™¤èŠ‚ç‚¹
    Node* removeHelper(Node* node, int key) {
        if (!node) return nullptr;
        
        if (key < node->key) {
            node->left = removeHelper(node->left, key);
        } else if (key > node->key) {
            node->right = removeHelper(node->right, key);
        } else {
            // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
            if (!node->left && !node->right) {
                delete node;
                return nullptr;
            } else if (!node->left) {
                Node* temp = node->right;
                delete node;
                return temp;
            } else if (!node->right) {
                Node* temp = node->left;
                delete node;
                return temp;
            } else {
                // æ‰¾åç»§
                Node* successor = node->right;
                while (successor->left) {
                    successor = successor->left;
                }
                node->key = successor->key;
                node->right = removeHelper(node->right, successor->key);
            }
        }
        
        updateSize(node);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ„
        if (needRebuild(node)) {
            return rebuild(node);
        }
        
        return node;
    }
    
public:
    ScapegoatTree(double a = 0.75) : root(nullptr), alpha(a) {}
    
    // æ’å…¥
    void insert(int key) {
        root = insertHelper(root, key);
    }
    
    // æŸ¥æ‰¾
    bool search(int key) {
        return searchHelper(root, key);
    }
    
    // åˆ é™¤
    void remove(int key) {
        root = removeHelper(root, key);
    }
    
    // ä¸­åºéå†
    void inorder() {
        inorderHelper(root);
        cout << endl;
    }
    
    void inorderHelper(Node* node) {
        if (!node) return;
        inorderHelper(node->left);
        cout << node->key << " ";
        inorderHelper(node->right);
    }
    
    // æ˜¾ç¤ºæ ‘ç»“æ„
    void printTree() {
        cout << "å½“å‰æ ‘ç»“æ„ (Î±=" << alpha << ")ï¼š" << endl;
        printHelper(root, "", true);
        cout << endl;
    }
    
    void printHelper(Node* node, string indent, bool isLast) {
        if (!node) return;
        
        cout << indent;
        if (isLast) {
            cout << "â””â”€â”€ ";
            indent += "    ";
        } else {
            cout << "â”œâ”€â”€ ";
            indent += "â”‚   ";
        }
        
        cout << node->key << "(size:" << node->size << ")";
        
        // æ˜¾ç¤ºæ˜¯å¦éœ€è¦é‡æ„
        if (needRebuild(node)) {
            cout << " [éœ€è¦é‡æ„!]";
        }
        cout << endl;
        
        if (node->left || node->right) {
            if (node->right) {
                printHelper(node->right, indent, !node->left);
            }
            if (node->left) {
                printHelper(node->left, indent, true);
            }
        }
    }
};
```

### ğŸ® æµ‹è¯•ä»£ç 

```cpp
int main() {
    ScapegoatTree tree;
    
    cout << "=== æ›¿ç½ªç¾Šæ ‘æ¼”ç¤º ===" << endl;
    
    // æ’å…¥æ•°æ®ï¼Œè§‚å¯Ÿé‡æ„è¿‡ç¨‹
    cout << "ä¾æ¬¡æ’å…¥: 1, 2, 3, 4, 5, 6, 7" << endl;
    
    for (int i = 1; i <= 7; i++) {
        cout << "\næ’å…¥ " << i << ":" << endl;
        tree.insert(i);
        tree.printTree();
    }
    
    cout << "\nä¸­åºéå†ï¼š";
    tree.inorder();
    
    // åˆ é™¤æµ‹è¯•
    cout << "\nåˆ é™¤ 4ï¼š" << endl;
    tree.remove(4);
    tree.printTree();
    
    // æŸ¥æ‰¾æµ‹è¯•
    cout << "æŸ¥æ‰¾ 3: " << (tree.search(3) ? "æ‰¾åˆ°" : "æœªæ‰¾åˆ°") << endl;
    cout << "æŸ¥æ‰¾ 4: " << (tree.search(4) ? "æ‰¾åˆ°" : "æœªæ‰¾åˆ°") << endl;
    
    return 0;
}
```

---

## ğŸŒŸ ç¬¬äº”ç« ï¼šå®Œæ•´åŠŸèƒ½ç‰ˆæœ¬

### ğŸ¯ æ”¯æŒæ’åæŸ¥è¯¢

```cpp
class AdvancedScapegoatTree {
private:
    struct Node {
        int key;
        int size;
        Node* left;
        Node* right;
        
        Node(int k) : key(k), size(1), left(nullptr), right(nullptr) {}
    };
    
    Node* root;
    double alpha;
    vector<Node*> nodes;
    
    void updateSize(Node* node) {
        if (!node) return;
        node->size = 1;
        if (node->left) node->size += node->left->size;
        if (node->right) node->size += node->right->size;
    }
    
    bool needRebuild(Node* node) {
        if (!node) return false;
        
        int leftSize = node->left ? node->left->size : 0;
        int rightSize = node->right ? node->right->size : 0;
        
        return leftSize > alpha * node->size || 
               rightSize > alpha * node->size;
    }
    
    void collectNodes(Node* node) {
        if (!node) return;
        collectNodes(node->left);
        nodes.push_back(node);
        collectNodes(node->right);
    }
    
    Node* buildBalanced(int left, int right) {
        if (left > right) return nullptr;
        
        int mid = (left + right) / 2;
        Node* node = nodes[mid];
        
        node->left = buildBalanced(left, mid - 1);
        node->right = buildBalanced(mid + 1, right);
        
        updateSize(node);
        return node;
    }
    
    Node* rebuild(Node* node) {
        if (!node) return nullptr;
        
        nodes.clear();
        collectNodes(node);
        
        return buildBalanced(0, nodes.size() - 1);
    }
    
    Node* insertHelper(Node* node, int key) {
        if (!node) {
            return new Node(key);
        }
        
        if (key < node->key) {
            node->left = insertHelper(node->left, key);
        } else if (key > node->key) {
            node->right = insertHelper(node->right, key);
        } else {
            return node;
        }
        
        updateSize(node);
        
        if (needRebuild(node)) {
            return rebuild(node);
        }
        
        return node;
    }
    
    Node* removeHelper(Node* node, int key) {
        if (!node) return nullptr;
        
        if (key < node->key) {
            node->left = removeHelper(node->left, key);
        } else if (key > node->key) {
            node->right = removeHelper(node->right, key);
        } else {
            if (!node->left && !node->right) {
                delete node;
                return nullptr;
            } else if (!node->left) {
                Node* temp = node->right;
                delete node;
                return temp;
            } else if (!node->right) {
                Node* temp = node->left;
                delete node;
                return temp;
            } else {
                Node* successor = node->right;
                while (successor->left) {
                    successor = successor->left;
                }
                node->key = successor->key;
                node->right = removeHelper(node->right, successor->key);
            }
        }
        
        updateSize(node);
        
        if (needRebuild(node)) {
            return rebuild(node);
        }
        
        return node;
    }
    
    bool searchHelper(Node* node, int key) {
        if (!node) return false;
        
        if (key == node->key) return true;
        else if (key < node->key) return searchHelper(node->left, key);
        else return searchHelper(node->right, key);
    }
    
    // æŸ¥æ‰¾ç¬¬kå°å…ƒç´ 
    int kthHelper(Node* node, int k) {
        if (!node) return -1;
        
        int leftSize = node->left ? node->left->size : 0;
        
        if (k <= leftSize) {
            return kthHelper(node->left, k);
        } else if (k == leftSize + 1) {
            return node->key;
        } else {
            return kthHelper(node->right, k - leftSize - 1);
        }
    }
    
    // æŸ¥æ‰¾æ’å
    int getRankHelper(Node* node, int key) {
        if (!node) return 0;
        
        if (key < node->key) {
            return getRankHelper(node->left, key);
        } else if (key == node->key) {
            return (node->left ? node->left->size : 0) + 1;
        } else {
            return (node->left ? node->left->size : 0) + 1 + 
                   getRankHelper(node->right, key);
        }
    }
    
    // æŸ¥æ‰¾å‰é©±
    int getPredecessorHelper(Node* node, int key) {
        if (!node) return -1;
        
        if (node->key >= key) {
            return getPredecessorHelper(node->left, key);
        } else {
            int rightResult = getPredecessorHelper(node->right, key);
            return rightResult == -1 ? node->key : rightResult;
        }
    }
    
    // æŸ¥æ‰¾åç»§
    int getSuccessorHelper(Node* node, int key) {
        if (!node) return -1;
        
        if (node->key <= key) {
            return getSuccessorHelper(node->right, key);
        } else {
            int leftResult = getSuccessorHelper(node->left, key);
            return leftResult == -1 ? node->key : leftResult;
        }
    }
    
public:
    AdvancedScapegoatTree(double a = 0.75) : root(nullptr), alpha(a) {}
    
    void insert(int key) {
        root = insertHelper(root, key);
    }
    
    bool search(int key) {
        return searchHelper(root, key);
    }
    
    void remove(int key) {
        root = removeHelper(root, key);
    }
    
    int kth(int k) {
        return kthHelper(root, k);
    }
    
    int getRank(int key) {
        return getRankHelper(root, key);
    }
    
    int getPredecessor(int key) {
        return getPredecessorHelper(root, key);
    }
    
    int getSuccessor(int key) {
        return getSuccessorHelper(root, key);
    }
    
    void printTree() {
        cout << "å½“å‰æ ‘ç»“æ„ (Î±=" << alpha << ")ï¼š" << endl;
        printHelper(root, "", true);
        cout << endl;
    }
    
    void printHelper(Node* node, string indent, bool isLast) {
        if (!node) return;
        
        cout << indent;
        if (isLast) {
            cout << "â””â”€â”€ ";
            indent += "    ";
        } else {
            cout << "â”œâ”€â”€ ";
            indent += "â”‚   ";
        }
        
        cout << node->key << "(size:" << node->size << ")";
        
        if (needRebuild(node)) {
            cout << " [æ›¿ç½ªç¾Š!]";
        }
        cout << endl;
        
        if (node->left || node->right) {
            if (node->right) {
                printHelper(node->right, indent, !node->left);
            }
            if (node->left) {
                printHelper(node->left, indent, true);
            }
        }
    }
};
```

---

## ğŸ¯ ç¬¬å…­ç« ï¼šæ›¿ç½ªç¾Šæ ‘çš„ä¼˜ç¼ºç‚¹

### âœ¨ ä¼˜ç‚¹

1. **å®ç°ç®€å•** - ä¸éœ€è¦å¤æ‚çš„æ—‹è½¬æ“ä½œ
2. **å¸¸æ•°å› å­å°** - å¤§éƒ¨åˆ†æ—¶é—´ä¸éœ€è¦ç»´æŠ¤å¹³è¡¡
3. **å†…å­˜å‹å¥½** - ä¸éœ€è¦é¢å¤–çš„å¹³è¡¡ä¿¡æ¯
4. **å®¹æ˜“ç†è§£** - é‡æ„çš„æ€æƒ³å¾ˆç›´è§‚

### ğŸª ç¼ºç‚¹

1. **é‡æ„ä»£ä»·é«˜** - å•æ¬¡é‡æ„éœ€è¦O(n)æ—¶é—´
2. **ä¸é€‚åˆé¢‘ç¹æ›´æ–°** - å¦‚æœæ›´æ–°å¾ˆé¢‘ç¹ï¼Œä¼šç»å¸¸é‡æ„
3. **æœ€åæƒ…å†µå·®** - è™½ç„¶æ‘Šè¿˜å¤æ‚åº¦å¥½ï¼Œä½†å•æ¬¡æ“ä½œå¯èƒ½å¾ˆæ…¢

### ğŸ“Š æ€§èƒ½å¯¹æ¯”

| æ“ä½œ | å¹³å‡æ—¶é—´ | æœ€åæ—¶é—´ | æ‘Šè¿˜æ—¶é—´ |
|------|----------|----------|----------|
| æ’å…¥ | O(log n) | O(n) | O(log n) |
| åˆ é™¤ | O(log n) | O(n) | O(log n) |
| æŸ¥æ‰¾ | O(log n) | O(n) | O(log n) |
| é‡æ„ | O(n) | O(n) | æ‘Šè¿˜åˆ°æ‰€æœ‰æ“ä½œä¸­ |

---

## ğŸ“ ç¬¬ä¸ƒç« ï¼šç»å…¸åº”ç”¨

### ğŸŒŸ åŠ¨æ€ç¬¬kå¤§é—®é¢˜

```cpp
int main() {
    AdvancedScapegoatTree tree;
    
    cout << "=== åŠ¨æ€ç¬¬kå¤§é—®é¢˜ ===" << endl;
    
    // æ’å…¥ä¸€äº›æ•°æ®
    vector<int> data = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3};
    
    for (int x : data) {
        tree.insert(x);
        cout << "æ’å…¥ " << x << " åï¼š" << endl;
        cout << "ç¬¬1å°ï¼š" << tree.kth(1) << endl;
        cout << "ç¬¬2å°ï¼š" << tree.kth(2) << endl;
        cout << "ç¬¬3å°ï¼š" << tree.kth(3) << endl;
        cout << "----------" << endl;
    }
    
    return 0;
}
```

### ğŸ¯ æ´›è°·P3369 - æ™®é€šå¹³è¡¡æ ‘

```cpp
int main() {
    AdvancedScapegoatTree tree;
    int n;
    cin >> n;
    
    while (n--) {
        int op, x;
        cin >> op >> x;
        
        switch (op) {
            case 1:
                tree.insert(x);
                break;
            case 2:
                tree.remove(x);
                break;
            case 3:
                cout << tree.getRank(x) << "\n";
                break;
            case 4:
                cout << tree.kth(x) << "\n";
                break;
            case 5:
                cout << tree.getPredecessor(x) << "\n";
                break;
            case 6:
                cout << tree.getSuccessor(x) << "\n";
                break;
        }
    }
    
    return 0;
}
```

### ğŸ® æ»‘åŠ¨çª—å£æœ€å€¼é—®é¢˜

```cpp
class SlidingWindowMax {
private:
    AdvancedScapegoatTree tree;
    queue<int> window;
    int windowSize;
    
public:
    SlidingWindowMax(int size) : windowSize(size) {}
    
    int addAndGetMax(int val) {
        // æ·»åŠ æ–°å…ƒç´ 
        tree.insert(val);
        window.push(val);
        
        // ç§»é™¤è¿‡æœŸå…ƒç´ 
        if (window.size() > windowSize) {
            int oldVal = window.front();
            window.pop();
            tree.remove(oldVal);
        }
        
        // è¿”å›æœ€å¤§å€¼ï¼ˆæœ€åä¸€ä¸ªå…ƒç´ ï¼‰
        return tree.kth(tree.root ? tree.root->size : 0);
    }
};
```

---

## ğŸª ç¬¬å…«ç« ï¼šè°ƒè¯•ä¸ä¼˜åŒ–

### ğŸ” è°ƒè¯•æŠ€å·§

1. **å¯è§†åŒ–é‡æ„è¿‡ç¨‹**
```cpp
void debugRebuild(Node* node) {
    cout << "é‡æ„å‰ï¼š" << endl;
    printTree();
    
    Node* newRoot = rebuild(node);
    
    cout << "é‡æ„åï¼š" << endl;
    printTree();
    
    return newRoot;
}
```

2. **ç»Ÿè®¡é‡æ„æ¬¡æ•°**
```cpp
class DebugScapegoatTree {
private:
    int rebuildCount = 0;
    
    Node* rebuild(Node* node) {
        rebuildCount++;
        cout << "ç¬¬ " << rebuildCount << " æ¬¡é‡æ„" << endl;
        return normalRebuild(node);
    }
    
public:
    int getRebuildCount() { return rebuildCount; }
};
```

### ğŸš€ ä¼˜åŒ–æŠ€å·§

1. **è°ƒæ•´Î±å€¼**
```cpp
void setAlpha(double newAlpha) {
    alpha = max(0.5, min(1.0, newAlpha));
}
```

2. **æ‰¹é‡æ’å…¥ä¼˜åŒ–**
```cpp
void batchInsert(vector<int>& data) {
    sort(data.begin(), data.end());
    
    for (int val : data) {
        insertWithoutRebuild(val);
    }
    
    // æœ€åç»Ÿä¸€é‡æ„
    if (needRebuild(root)) {
        root = rebuild(root);
    }
}
```

---

## ğŸ¯ æ€»ç»“

### ğŸŒ¸ è®°ä½è¿™äº›å…³é”®ç‚¹

1. **æ›¿ç½ªç¾Šæ ‘ = æ‡’æƒ°ç­–ç•¥** - å¹³æ—¶ä¸ç®¡ï¼Œä¸¥é‡äº†æ‰é‡æ„
2. **Î±å€¼æ§åˆ¶å¹³è¡¡åº¦** - é€šå¸¸é€‰æ‹©0.75
3. **é‡æ„æ˜¯å…³é”®** - ä¸­åºéå†æ”¶é›†ï¼Œé‡æ–°æ„å»º
4. **æ‘Šè¿˜å¤æ‚åº¦å¥½** - è™½ç„¶å•æ¬¡é‡æ„ä»£ä»·é«˜ï¼Œä½†å¹³å‡ä¸‹æ¥å¾ˆå¥½

### ğŸŒŸ é€‚ç”¨åœºæ™¯

- **æŸ¥è¯¢å¤šï¼Œæ›´æ–°å°‘** - é€‚åˆè¯»å¤šå†™å°‘çš„åœºæ™¯
- **å†…å­˜æ•æ„Ÿ** - ä¸éœ€è¦é¢å¤–çš„å¹³è¡¡ä¿¡æ¯
- **å®ç°ç®€å•** - æ¯”å…¶ä»–å¹³è¡¡æ ‘å®¹æ˜“å®ç°

### ğŸª å­¦ä¹ å»ºè®®

1. **ç†è§£é‡æ„æ€æƒ³** - è¿™æ˜¯æ›¿ç½ªç¾Šæ ‘çš„æ ¸å¿ƒ
2. **æŒæ¡Î±å€¼çš„ä½œç”¨** - æ§åˆ¶é‡æ„çš„é¢‘ç‡
3. **ç»ƒä¹ å®ç°** - ä»£ç ç›¸å¯¹ç®€å•ï¼Œå®¹æ˜“ä¸Šæ‰‹
4. **åˆ†æå¤æ‚åº¦** - ç†è§£æ‘Šè¿˜åˆ†æçš„æ€æƒ³

### ğŸš€ ä¸‹èŠ‚è¯¾é¢„å‘Š

ä¸‹æ¬¡æˆ‘ä»¬å°†å­¦ä¹ **æƒé‡å¹³è¡¡æ ‘ï¼ˆé‡ç‚¹FHQ-Treapï¼‰**ï¼Œçœ‹çœ‹OIç«èµ›ä¸­æœ€å—æ¬¢è¿çš„å¹³è¡¡æ ‘æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼

---

**ğŸŒ¸ "æ›¿ç½ªç¾Šæ ‘å‘Šè¯‰æˆ‘ä»¬ï¼šæœ‰æ—¶å€™ï¼Œé‡æ–°å¼€å§‹æ¯”ä¿®ä¿®è¡¥è¡¥æ›´æœ‰æ•ˆï¼" - ãƒ¦ã‚ºè€å¸ˆ**

*åƒç¦§å¹´ç§‘æŠ€å­¦é™¢ - è®©å¤æ‚çš„æ•°æ®ç»“æ„å˜å¾—ç®€å•æœ‰è¶£ï¼* 