# ğŸ† æƒé‡å¹³è¡¡æ ‘ - OIç«èµ›çš„ç‹è€…ä¹‹é€‰
## *åƒç¦§å¹´ç§‘æŠ€å­¦é™¢ - ã‚¢ãƒªã‚¹ & ãƒ¦ã‚¦ã‚« & ãƒ¦ã‚º è”åˆæˆè¯¾*

*"åœ¨OIçš„ä¸–ç•Œé‡Œï¼Œæœ‰ä¸€ä¸ªä¼ è¯´ï¼šæŒæ¡äº†FHQ-Treapï¼Œå°±æŒæ¡äº†å¹³è¡¡æ ‘çš„çœŸè°›ï¼"*

---

## ğŸª å¼€å§‹ä¹‹å‰ - ä¸ºä»€ä¹ˆå­¦æƒé‡å¹³è¡¡æ ‘ï¼Ÿ

### ğŸŒŸ ç«èµ›ç°å®

åœ¨OIç«èµ›ä¸­ï¼Œä½ ä¼šå‘ç°ï¼š
- ğŸ”¥ **90%çš„é€‰æ‰‹ç”¨FHQ-Treap**
- âš¡ **ä»£ç çŸ­ï¼Œå¥½å†™ï¼Œä¸å®¹æ˜“é”™**
- ğŸ† **åŠŸèƒ½å¼ºå¤§ï¼Œå‡ ä¹ä¸‡èƒ½**
- ğŸ“š **å­¦ä¼šä¸€ä¸ªï¼Œèµ°éå¤©ä¸‹**

### ğŸ¯ æœ¬èŠ‚è¯¾é‡ç‚¹

æˆ‘ä»¬å°†é‡ç‚¹è®²è§£**FHQ-Treap**ï¼ˆæ— æ—‹Treapï¼‰ï¼š
- ğŸ“– **ä¸ºä»€ä¹ˆå«"æƒé‡å¹³è¡¡æ ‘"ï¼Ÿ**
- ğŸª **ä¸¤ä¸ªæ ¸å¿ƒæ“ä½œï¼šsplitå’Œmerge**
- ğŸ’» **ä»é›¶å¼€å§‹æ‰‹æŠŠæ‰‹å®ç°**
- ğŸ† **è§£å†³OIç»å…¸é¢˜ç›®**

---

## ğŸ“– ç¬¬ä¸€ç« ï¼šä»€ä¹ˆæ˜¯æƒé‡å¹³è¡¡æ ‘ï¼Ÿ

### ğŸŒ¸ æƒé‡çš„å«ä¹‰

**æƒé‡å¹³è¡¡æ ‘ä¸­çš„"æƒé‡"æŒ‡çš„æ˜¯ä»€ä¹ˆï¼Ÿ**

ä»¥FHQ-Treapä¸ºä¾‹ï¼š
- ğŸ² æ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸€ä¸ª**éšæœºæƒé‡ï¼ˆä¼˜å…ˆçº§ï¼‰**
- âš–ï¸ é€šè¿‡æƒé‡ç»´æŠ¤æ ‘çš„**å¹³è¡¡æ€§**
- ğŸ¯ æƒé‡è¶Šå¤§ï¼Œè¶Šå®¹æ˜“åœ¨æ ‘çš„**ä¸Šå±‚**

### ğŸ® æ¸¸æˆåŒ–ç†è§£

æƒ³è±¡ä½ åœ¨ç©**è‹±é›„è”ç›Ÿçš„æ’ä½ç³»ç»Ÿ**ï¼š
- ğŸ… æ¯ä¸ªè‹±é›„æœ‰ä¸€ä¸ª**éšè—åˆ†æ•°**ï¼ˆæƒé‡ï¼‰
- ğŸ“ˆ åˆ†æ•°é«˜çš„è‹±é›„æ’åœ¨**ä¸Šæ–¹**
- âš–ï¸ ç³»ç»Ÿè‡ªåŠ¨ç»´æŒ**å¹³è¡¡çš„åŒ¹é…**
- ğŸ² æœ‰ä¸€å®šçš„**éšæœºæ€§**ä¿è¯å…¬å¹³

### ğŸ“Š å®é™…ä¾‹å­

```
èŠ‚ç‚¹ï¼š(å€¼, æƒé‡)

åŸå§‹æ•°æ®ï¼š(10,45), (5,78), (15,23), (20,89)
æŒ‰å€¼æ’åºï¼š5 < 10 < 15 < 20
æŒ‰æƒé‡æ’åºï¼š89 > 78 > 45 > 23

FHQ-Treapç»“æ„ï¼š
       (20,89)     â† æƒé‡æœ€å¤§åœ¨é¡¶éƒ¨
      /
    (5,78)         â† æƒé‡ç¬¬äºŒå¤§
      \
      (10,45)
        \
        (15,23)    â† æƒé‡æœ€å°åœ¨åº•éƒ¨
```

**æ—¢æ»¡è¶³BSTæ€§è´¨ï¼Œåˆæ»¡è¶³å †æ€§è´¨ï¼**

---

## ğŸš€ ç¬¬äºŒç« ï¼šFHQ-Treapçš„æ ¸å¿ƒæ€æƒ³

### ğŸŒŸ ä¸ºä»€ä¹ˆå«FHQ-Treapï¼Ÿ

- **FHQ**ï¼šèŒƒæµ©å¼ºï¼ˆå‘æ˜è€…çš„åå­—ï¼‰
- **Treap**ï¼šTree + Heap
- **ç‰¹ç‚¹**ï¼šæ— éœ€æ—‹è½¬ï¼Œåªç”¨splitå’Œmerge

### ğŸ¯ ä¸¤ä¸ªç¥å¥‡æ“ä½œ

#### ğŸ”¥ Splitï¼ˆåˆ†è£‚ï¼‰
æŠŠä¸€æ£µæ ‘åˆ†æˆä¸¤æ£µæ ‘ï¼š
```
è¾“å…¥ï¼šä¸€æ£µæ ‘ + åˆ†ç•Œå€¼k
è¾“å‡ºï¼šå·¦æ ‘ï¼ˆâ‰¤kï¼‰+ å³æ ‘ï¼ˆ>kï¼‰
```

#### âš¡ Mergeï¼ˆåˆå¹¶ï¼‰
æŠŠä¸¤æ£µæ ‘åˆå¹¶æˆä¸€æ£µæ ‘ï¼š
```
è¾“å…¥ï¼šå·¦æ ‘ + å³æ ‘ï¼ˆå·¦æ ‘æ‰€æœ‰å€¼ < å³æ ‘æ‰€æœ‰å€¼ï¼‰
è¾“å‡ºï¼šåˆå¹¶åçš„æ ‘
```

### ğŸª ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ

**ä¼ ç»Ÿå¹³è¡¡æ ‘ï¼š**
- ğŸ˜° éœ€è¦å¤æ‚çš„æ—‹è½¬
- ğŸŒ€ å·¦æ—‹ã€å³æ—‹ã€åŒæ—‹...
- ğŸ¤¯ å®¹æ˜“å†™é”™ï¼Œéš¾ä»¥è°ƒè¯•

**FHQ-Treapï¼š**
- ğŸ˜Š åªéœ€è¦splitå’Œmerge
- âœ¨ æ€è·¯æ¸…æ™°ï¼Œé€»è¾‘ç®€å•
- ğŸ¯ ä¸¤ä¸ªæ“ä½œè§£å†³æ‰€æœ‰é—®é¢˜

---

## ğŸ’» ç¬¬ä¸‰ç« ï¼šæ‰‹æŠŠæ‰‹å®ç°

### ğŸŒ¸ åŸºç¡€ç»“æ„

```cpp
#include <iostream>
#include <random>
using namespace std;

struct Node {
    int val;      // èŠ‚ç‚¹å€¼
    int priority; // éšæœºæƒé‡
    int size;     // å­æ ‘å¤§å°
    Node* left;
    Node* right;
    
    Node(int v) : val(v), priority(rand()), size(1), 
                  left(nullptr), right(nullptr) {}
};

class FHQTreap {
private:
    Node* root;
    
    // æ›´æ–°å­æ ‘å¤§å°
    void updateSize(Node* node) {
        if (!node) return;
        node->size = 1;
        if (node->left) node->size += node->left->size;
        if (node->right) node->size += node->right->size;
    }
    
public:
    FHQTreap() : root(nullptr) {
        srand(time(0));  // åˆå§‹åŒ–éšæœºç§å­
    }
};
```

### ğŸ¯ æ ¸å¿ƒæ“ä½œï¼šSplit

**æ€è·¯ï¼š** é€’å½’åœ°æŒ‰å€¼åˆ†è£‚
```cpp
// æŒ‰å€¼åˆ†è£‚ï¼šâ‰¤valçš„æ”¾å·¦è¾¹ï¼Œ>valçš„æ”¾å³è¾¹
void split(Node* root, int val, Node*& left, Node*& right) {
    if (!root) {
        left = right = nullptr;
        return;
    }
    
    if (root->val <= val) {
        // å½“å‰èŠ‚ç‚¹æ”¾åˆ°å·¦è¾¹
        left = root;
        split(root->right, val, left->right, right);
    } else {
        // å½“å‰èŠ‚ç‚¹æ”¾åˆ°å³è¾¹
        right = root;
        split(root->left, val, left, right->left);
    }
    
    updateSize(left);
    updateSize(right);
}
```

### âš¡ æ ¸å¿ƒæ“ä½œï¼šMerge

**æ€è·¯ï¼š** æŒ‰æƒé‡å†³å®šè°åšæ ¹
```cpp
// åˆå¹¶ä¸¤æ£µæ ‘ï¼ˆè¦æ±‚leftçš„æ‰€æœ‰å€¼ < rightçš„æ‰€æœ‰å€¼ï¼‰
Node* merge(Node* left, Node* right) {
    if (!left) return right;
    if (!right) return left;
    
    if (left->priority > right->priority) {
        // leftçš„æƒé‡å¤§ï¼Œleftåšæ ¹
        left->right = merge(left->right, right);
        updateSize(left);
        return left;
    } else {
        // rightçš„æƒé‡å¤§ï¼Œrightåšæ ¹
        right->left = merge(left, right->left);
        updateSize(right);
        return right;
    }
}
```

### ğŸ† åŸºæœ¬æ“ä½œå®ç°

```cpp
// æ’å…¥
void insert(int val) {
    Node* left, *right;
    split(root, val, left, right);
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    Node* temp;
    split(left, val - 1, left, temp);
    
    if (!temp) {
        temp = new Node(val);
    }
    
    root = merge(merge(left, temp), right);
}

// åˆ é™¤
void remove(int val) {
    Node* left, *right, *temp;
    split(root, val, left, right);
    split(left, val - 1, left, temp);
    
    if (temp) {
        delete temp;
    }
    
    root = merge(left, right);
}

// æŸ¥æ‰¾
bool search(int val) {
    Node* left, *right, *temp;
    split(root, val, left, right);
    split(left, val - 1, left, temp);
    
    bool found = (temp != nullptr);
    
    root = merge(merge(left, temp), right);
    return found;
}
```

---

## ğŸ¯ ç¬¬å››ç« ï¼šå®Œæ•´å®ç°ï¼ˆæ”¯æŒæ’åï¼‰

### ğŸŒŸ åŠ å¼ºç‰ˆFHQ-Treap

```cpp
class AdvancedFHQTreap {
private:
    struct Node {
        int val, priority, size;
        Node* left;
        Node* right;
        
        Node(int v) : val(v), priority(rand()), size(1), 
                      left(nullptr), right(nullptr) {}
    };
    
    Node* root;
    
    void updateSize(Node* node) {
        if (!node) return;
        node->size = 1;
        if (node->left) node->size += node->left->size;
        if (node->right) node->size += node->right->size;
    }
    
    void split(Node* root, int val, Node*& left, Node*& right) {
        if (!root) {
            left = right = nullptr;
            return;
        }
        
        if (root->val <= val) {
            left = root;
            split(root->right, val, left->right, right);
        } else {
            right = root;
            split(root->left, val, left, right->left);
        }
        updateSize(left);
        updateSize(right);
    }
    
    // æŒ‰æ’ååˆ†è£‚
    void splitByRank(Node* root, int rank, Node*& left, Node*& right) {
        if (!root) {
            left = right = nullptr;
            return;
        }
        
        int leftSize = root->left ? root->left->size : 0;
        
        if (leftSize < rank) {
            left = root;
            splitByRank(root->right, rank - leftSize - 1, left->right, right);
        } else {
            right = root;
            splitByRank(root->left, rank, left, right->left);
        }
        updateSize(left);
        updateSize(right);
    }
    
    Node* merge(Node* left, Node* right) {
        if (!left) return right;
        if (!right) return left;
        
        if (left->priority > right->priority) {
            left->right = merge(left->right, right);
            updateSize(left);
            return left;
        } else {
            right->left = merge(left, right->left);
            updateSize(right);
            return right;
        }
    }
    
public:
    AdvancedFHQTreap() : root(nullptr) {
        srand(time(0));
    }
    
    // æ’å…¥
    void insert(int val) {
        Node* left, *right;
        split(root, val, left, right);
        
        Node* temp;
        split(left, val - 1, left, temp);
        
        if (!temp) {
            temp = new Node(val);
        }
        
        root = merge(merge(left, temp), right);
    }
    
    // åˆ é™¤
    void remove(int val) {
        Node* left, *right, *temp;
        split(root, val, left, right);
        split(left, val - 1, left, temp);
        
        if (temp) {
            delete temp;
        }
        
        root = merge(left, right);
    }
    
    // æŸ¥æ‰¾ç¬¬kå°ï¼ˆ1-indexedï¼‰
    int kth(int k) {
        Node* left, *right, *temp;
        splitByRank(root, k - 1, left, right);
        splitByRank(right, 1, temp, right);
        
        int result = temp ? temp->val : -1;
        
        root = merge(merge(left, temp), right);
        return result;
    }
    
    // æŸ¥è¯¢æ’å
    int getRank(int val) {
        Node* left, *right;
        split(root, val - 1, left, right);
        
        int rank = (left ? left->size : 0) + 1;
        
        root = merge(left, right);
        return rank;
    }
    
    // æŸ¥è¯¢å‰é©±
    int getPrev(int val) {
        Node* left, *right;
        split(root, val - 1, left, right);
        
        int result = -1;
        if (left) {
            Node* temp1, *temp2;
            splitByRank(left, left->size - 1, temp1, temp2);
            if (temp2) result = temp2->val;
            left = merge(temp1, temp2);
        }
        
        root = merge(left, right);
        return result;
    }
    
    // æŸ¥è¯¢åç»§
    int getNext(int val) {
        Node* left, *right;
        split(root, val, left, right);
        
        int result = -1;
        if (right) {
            Node* temp1, *temp2;
            splitByRank(right, 1, temp1, temp2);
            if (temp1) result = temp1->val;
            right = merge(temp1, temp2);
        }
        
        root = merge(left, right);
        return result;
    }
    
    // æ˜¾ç¤ºæ ‘ç»“æ„
    void printTree() {
        cout << "å½“å‰FHQ-Treapç»“æ„ï¼š" << endl;
        printHelper(root, "", true);
        cout << endl;
    }
    
    void printHelper(Node* node, string indent, bool isLast) {
        if (!node) return;
        
        cout << indent;
        if (isLast) {
            cout << "â””â”€â”€ ";
            indent += "    ";
        } else {
            cout << "â”œâ”€â”€ ";
            indent += "â”‚   ";
        }
        cout << "(" << node->val << "," << node->priority << ",size:" << node->size << ")" << endl;
        
        if (node->left || node->right) {
            if (node->right) {
                printHelper(node->right, indent, !node->left);
            }
            if (node->left) {
                printHelper(node->left, indent, true);
            }
        }
    }
};
```

---

## ğŸ® ç¬¬äº”ç« ï¼šåŒºé—´æ“ä½œç‰ˆæœ¬

### ğŸŒŸ æ–‡è‰ºå¹³è¡¡æ ‘ï¼ˆæ”¯æŒåŒºé—´ç¿»è½¬ï¼‰

```cpp
class IntervalFHQTreap {
private:
    struct Node {
        int val, priority, size;
        bool reversed;
        Node* left;
        Node* right;
        
        Node(int v) : val(v), priority(rand()), size(1), 
                      reversed(false), left(nullptr), right(nullptr) {}
    };
    
    Node* root;
    
    void pushDown(Node* node) {
        if (!node || !node->reversed) return;
        
        // äº¤æ¢å·¦å³å­æ ‘
        swap(node->left, node->right);
        
        // ä¼ é€’ç¿»è½¬æ ‡è®°
        if (node->left) node->left->reversed ^= true;
        if (node->right) node->right->reversed ^= true;
        
        node->reversed = false;
    }
    
    void updateSize(Node* node) {
        if (!node) return;
        node->size = 1;
        if (node->left) node->size += node->left->size;
        if (node->right) node->size += node->right->size;
    }
    
    void splitByRank(Node* root, int rank, Node*& left, Node*& right) {
        if (!root) {
            left = right = nullptr;
            return;
        }
        
        pushDown(root);
        
        int leftSize = root->left ? root->left->size : 0;
        
        if (leftSize < rank) {
            left = root;
            splitByRank(root->right, rank - leftSize - 1, left->right, right);
        } else {
            right = root;
            splitByRank(root->left, rank, left, right->left);
        }
        updateSize(left);
        updateSize(right);
    }
    
    Node* merge(Node* left, Node* right) {
        if (!left) return right;
        if (!right) return left;
        
        if (left->priority > right->priority) {
            pushDown(left);
            left->right = merge(left->right, right);
            updateSize(left);
            return left;
        } else {
            pushDown(right);
            right->left = merge(left, right->left);
            updateSize(right);
            return right;
        }
    }
    
public:
    IntervalFHQTreap() : root(nullptr) {
        srand(time(0));
    }
    
    // ä»æ•°ç»„æ„å»º
    void build(vector<int>& arr) {
        for (int i = 0; i < arr.size(); i++) {
            insert(i + 1, arr[i]);
        }
    }
    
    // åœ¨ä½ç½®posæ’å…¥å€¼val
    void insert(int pos, int val) {
        Node* left, *right;
        splitByRank(root, pos - 1, left, right);
        
        Node* newNode = new Node(val);
        root = merge(merge(left, newNode), right);
    }
    
    // ç¿»è½¬åŒºé—´[l, r]
    void reverse(int l, int r) {
        Node* left, *right, *middle;
        
        // åˆ†ç¦»å‡º[l, r]åŒºé—´
        splitByRank(root, l - 1, left, right);
        splitByRank(right, r - l + 1, middle, right);
        
        // ç»™ä¸­é—´éƒ¨åˆ†æ‰“ç¿»è½¬æ ‡è®°
        if (middle) {
            middle->reversed ^= true;
        }
        
        // åˆå¹¶å›å»
        root = merge(merge(left, middle), right);
    }
    
    // è¾“å‡ºåºåˆ—
    void printSequence() {
        cout << "å½“å‰åºåˆ—ï¼š";
        printSequenceHelper(root);
        cout << endl;
    }
    
    void printSequenceHelper(Node* node) {
        if (!node) return;
        
        pushDown(node);
        printSequenceHelper(node->left);
        cout << node->val << " ";
        printSequenceHelper(node->right);
    }
};
```

---

## ğŸ† ç¬¬å…­ç« ï¼šç«èµ›æ¨¡æ¿

### ğŸ¯ æ´›è°·P3369æ¨¡æ¿

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int val, priority, size;
    Node* left;
    Node* right;
    
    Node(int v) : val(v), priority(rand()), size(1), 
                  left(nullptr), right(nullptr) {}
};

class FHQTreap {
private:
    Node* root;
    
    void updateSize(Node* node) {
        if (!node) return;
        node->size = 1;
        if (node->left) node->size += node->left->size;
        if (node->right) node->size += node->right->size;
    }
    
    void split(Node* root, int val, Node*& left, Node*& right) {
        if (!root) {
            left = right = nullptr;
            return;
        }
        
        if (root->val <= val) {
            left = root;
            split(root->right, val, left->right, right);
        } else {
            right = root;
            split(root->left, val, left, right->left);
        }
        updateSize(left);
        updateSize(right);
    }
    
    Node* merge(Node* left, Node* right) {
        if (!left) return right;
        if (!right) return left;
        
        if (left->priority > right->priority) {
            left->right = merge(left->right, right);
            updateSize(left);
            return left;
        } else {
            right->left = merge(left, right->left);
            updateSize(right);
            return right;
        }
    }
    
public:
    FHQTreap() : root(nullptr) {}
    
    void insert(int val) {
        Node* left, *right;
        split(root, val, left, right);
        
        Node* temp;
        split(left, val - 1, left, temp);
        
        if (!temp) {
            temp = new Node(val);
        }
        
        root = merge(merge(left, temp), right);
    }
    
    void remove(int val) {
        Node* left, *right, *temp;
        split(root, val, left, right);
        split(left, val - 1, left, temp);
        
        if (temp) {
            delete temp;
        }
        
        root = merge(left, right);
    }
    
    int getRank(int val) {
        Node* left, *right;
        split(root, val - 1, left, right);
        
        int rank = (left ? left->size : 0) + 1;
        
        root = merge(left, right);
        return rank;
    }
    
    int kth(int k) {
        return kthHelper(root, k);
    }
    
    int kthHelper(Node* node, int k) {
        if (!node) return -1;
        
        int leftSize = node->left ? node->left->size : 0;
        
        if (k <= leftSize) {
            return kthHelper(node->left, k);
        } else if (k == leftSize + 1) {
            return node->val;
        } else {
            return kthHelper(node->right, k - leftSize - 1);
        }
    }
    
    int getPrev(int val) {
        Node* left, *right;
        split(root, val - 1, left, right);
        
        int result = -1;
        if (left) {
            result = kthHelper(left, left->size);
        }
        
        root = merge(left, right);
        return result;
    }
    
    int getNext(int val) {
        Node* left, *right;
        split(root, val, left, right);
        
        int result = -1;
        if (right) {
            result = kthHelper(right, 1);
        }
        
        root = merge(left, right);
        return result;
    }
};

int main() {
    FHQTreap treap;
    int n;
    scanf("%d", &n);
    
    while (n--) {
        int op, x;
        scanf("%d %d", &op, &x);
        
        switch (op) {
            case 1:
                treap.insert(x);
                break;
            case 2:
                treap.remove(x);
                break;
            case 3:
                printf("%d\n", treap.getRank(x));
                break;
            case 4:
                printf("%d\n", treap.kth(x));
                break;
            case 5:
                printf("%d\n", treap.getPrev(x));
                break;
            case 6:
                printf("%d\n", treap.getNext(x));
                break;
        }
    }
    
    return 0;
}
```

### ğŸª æ´›è°·P3391æ¨¡æ¿ï¼ˆæ–‡è‰ºå¹³è¡¡æ ‘ï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int val, priority, size;
    bool reversed;
    Node* left;
    Node* right;
    
    Node(int v) : val(v), priority(rand()), size(1), 
                  reversed(false), left(nullptr), right(nullptr) {}
};

Node* root = nullptr;

void pushDown(Node* node) {
    if (!node || !node->reversed) return;
    
    swap(node->left, node->right);
    
    if (node->left) node->left->reversed ^= true;
    if (node->right) node->right->reversed ^= true;
    
    node->reversed = false;
}

void updateSize(Node* node) {
    if (!node) return;
    node->size = 1;
    if (node->left) node->size += node->left->size;
    if (node->right) node->size += node->right->size;
}

void split(Node* root, int rank, Node*& left, Node*& right) {
    if (!root) {
        left = right = nullptr;
        return;
    }
    
    pushDown(root);
    
    int leftSize = root->left ? root->left->size : 0;
    
    if (leftSize < rank) {
        left = root;
        split(root->right, rank - leftSize - 1, left->right, right);
    } else {
        right = root;
        split(root->left, rank, left, right->left);
    }
    updateSize(left);
    updateSize(right);
}

Node* merge(Node* left, Node* right) {
    if (!left) return right;
    if (!right) return left;
    
    if (left->priority > right->priority) {
        pushDown(left);
        left->right = merge(left->right, right);
        updateSize(left);
        return left;
    } else {
        pushDown(right);
        right->left = merge(left, right->left);
        updateSize(right);
        return right;
    }
}

void reverse(int l, int r) {
    Node* left, *right, *middle;
    
    split(root, l - 1, left, right);
    split(right, r - l + 1, middle, right);
    
    if (middle) {
        middle->reversed ^= true;
    }
    
    root = merge(merge(left, middle), right);
}

void printSequence(Node* node) {
    if (!node) return;
    
    pushDown(node);
    printSequence(node->left);
    printf("%d ", node->val);
    printSequence(node->right);
}

int main() {
    srand(time(0));
    
    int n, m;
    scanf("%d %d", &n, &m);
    
    // æ„å»ºåˆå§‹åºåˆ—
    for (int i = 1; i <= n; i++) {
        Node* newNode = new Node(i);
        root = merge(root, newNode);
    }
    
    // å¤„ç†ç¿»è½¬æ“ä½œ
    for (int i = 0; i < m; i++) {
        int l, r;
        scanf("%d %d", &l, &r);
        reverse(l, r);
    }
    
    // è¾“å‡ºç»“æœ
    printSequence(root);
    printf("\n");
    
    return 0;
}
```

---

## ğŸ¯ ç¬¬ä¸ƒç« ï¼šFHQ-Treapçš„ä¼˜åŠ¿

### âœ¨ ä¸ºä»€ä¹ˆé€‰æ‹©FHQ-Treapï¼Ÿ

| ç‰¹ç‚¹ | FHQ-Treap | å…¶ä»–å¹³è¡¡æ ‘ |
|------|-----------|------------|
| **ä»£ç é•¿åº¦** | çŸ­ | é•¿ |
| **å®ç°éš¾åº¦** | ç®€å• | å¤æ‚ |
| **è°ƒè¯•éš¾åº¦** | å®¹æ˜“ | å›°éš¾ |
| **åŠŸèƒ½æ€§** | å¼ºå¤§ | æœ‰é™ |
| **åŒºé—´æ“ä½œ** | å¤©ç„¶æ”¯æŒ | éœ€è¦é¢å¤–å®ç° |
| **å¯æŒä¹…åŒ–** | å®¹æ˜“ | å›°éš¾ |
| **ç«èµ›é€‚ç”¨æ€§** | æä½³ | ä¸€èˆ¬ |

### ğŸ† ç«èµ›ä¸­çš„åœ°ä½

1. **Codeforces** - 90%ä»¥ä¸Šé€‰æ‰‹çš„é€‰æ‹©
2. **ICPC** - é˜Ÿä¼æ ‡å‡†é…ç½®
3. **NOI/USACO** - å®˜æ–¹æ¨è
4. **AtCoder** - æ—¥æœ¬é€‰æ‰‹æœ€çˆ±

### ğŸª é€‚ç”¨é¢˜å‹

- âœ… **æ™®é€šå¹³è¡¡æ ‘** - æ’å…¥åˆ é™¤æŸ¥è¯¢
- âœ… **æ–‡è‰ºå¹³è¡¡æ ‘** - åŒºé—´ç¿»è½¬
- âœ… **åŒºé—´æ“ä½œ** - åŒºé—´åŠ ã€åŒºé—´æŸ¥è¯¢
- âœ… **åŠ¨æ€æ’å** - ç¬¬kå¤§ã€æ’åæŸ¥è¯¢
- âœ… **å¯æŒä¹…åŒ–** - å†å²ç‰ˆæœ¬æŸ¥è¯¢
- âœ… **åºåˆ—ç»´æŠ¤** - ä»»æ„ä½ç½®æ’å…¥åˆ é™¤

---

## ğŸ“ ç¬¬å…«ç« ï¼šç»å…¸ä¾‹é¢˜è§£æ

### ğŸŒŸ ä¾‹é¢˜1ï¼šæ´›è°·P3369 æ™®é€šå¹³è¡¡æ ‘

**é¢˜ç›®ï¼š** ç»´æŠ¤ä¸€ä¸ªæ•°é›†ï¼Œæ”¯æŒæ’å…¥ã€åˆ é™¤ã€æŸ¥è¯¢æ’åã€æŸ¥è¯¢ç¬¬kå¤§ã€æŸ¥è¯¢å‰é©±åç»§ã€‚

**æ€è·¯ï¼š** ç›´æ¥å¥—ç”¨FHQ-Treapæ¨¡æ¿å³å¯ã€‚

**å…³é”®ä»£ç ï¼š**
```cpp
// è§ä¸Šæ–¹æ¨¡æ¿ä»£ç 
```

### ğŸ¯ ä¾‹é¢˜2ï¼šæ´›è°·P3391 æ–‡è‰ºå¹³è¡¡æ ‘

**é¢˜ç›®ï¼š** ç»™å®šåºåˆ—1,2,...,nï¼Œæ”¯æŒåŒºé—´ç¿»è½¬æ“ä½œã€‚

**æ€è·¯ï¼š** ç”¨æ”¯æŒåŒºé—´æ“ä½œçš„FHQ-Treapï¼Œç»´æŠ¤ç¿»è½¬æ ‡è®°ã€‚

**å…³é”®ä»£ç ï¼š**
```cpp
// è§ä¸Šæ–¹æ¨¡æ¿ä»£ç 
```

### ğŸ† ä¾‹é¢˜3ï¼šåŠ¨æ€é€†åºå¯¹

**é¢˜ç›®ï¼š** åŠ¨æ€æ’å…¥æ•°å­—ï¼ŒæŸ¥è¯¢å½“å‰é€†åºå¯¹æ•°é‡ã€‚

**æ€è·¯ï¼š** 
1. æ’å…¥æ•°å­—xæ—¶ï¼Œç»Ÿè®¡å·²æœ‰æ•°å­—ä¸­å¤§äºxçš„ä¸ªæ•°
2. è¿™äº›æ•°å­—ä¸xå½¢æˆé€†åºå¯¹

**ä»£ç ï¼š**
```cpp
class DynamicInversion {
private:
    FHQTreap treap;
    long long inversions;
    
public:
    DynamicInversion() : inversions(0) {}
    
    void insert(int x) {
        // æŸ¥è¯¢æ¯”xå¤§çš„æ•°çš„ä¸ªæ•°
        Node* left, *right;
        treap.split(treap.root, x, left, right);
        
        int largerCount = right ? right->size : 0;
        inversions += largerCount;
        
        treap.root = treap.merge(left, right);
        treap.insert(x);
    }
    
    long long getInversions() {
        return inversions;
    }
};
```

---

## ğŸš€ ç¬¬ä¹ç« ï¼šè¿›é˜¶æŠ€å·§

### ğŸŒŸ å¯æŒä¹…åŒ–FHQ-Treap

```cpp
struct PersistentNode {
    int val, priority, size;
    PersistentNode* left;
    PersistentNode* right;
    
    PersistentNode(int v) : val(v), priority(rand()), size(1), 
                           left(nullptr), right(nullptr) {}
    
    PersistentNode(const PersistentNode& other) 
        : val(other.val), priority(other.priority), size(other.size),
          left(other.left), right(other.right) {}
};

class PersistentFHQTreap {
private:
    vector<PersistentNode*> versions;
    
    PersistentNode* copyNode(PersistentNode* node) {
        return node ? new PersistentNode(*node) : nullptr;
    }
    
public:
    void insert(int version, int val) {
        PersistentNode* oldRoot = versions[version];
        PersistentNode* newRoot = insertHelper(oldRoot, val);
        versions.push_back(newRoot);
    }
    
    // ... å…¶ä»–æ“ä½œç±»ä¼¼
};
```

### ğŸ¯ æƒå€¼çº¿æ®µæ ‘æ›¿ä»£

```cpp
// FHQ-Treapå¯ä»¥æ›¿ä»£æƒå€¼çº¿æ®µæ ‘
class ValueSegmentReplace {
private:
    FHQTreap treap;
    
public:
    void insert(int val) {
        treap.insert(val);
    }
    
    void remove(int val) {
        treap.remove(val);
    }
    
    int kth(int k) {
        return treap.kth(k);
    }
    
    int rank(int val) {
        return treap.getRank(val);
    }
    
    int countInRange(int l, int r) {
        return treap.getRank(r + 1) - treap.getRank(l);
    }
};
```

---

## ğŸª æ€»ç»“

### ğŸŒ¸ è®°ä½è¿™äº›å…³é”®ç‚¹

1. **FHQ-Treap = OIç¥å™¨** - ç«èµ›é¦–é€‰å¹³è¡¡æ ‘
2. **ä¸¤ä¸ªæ“ä½œèµ°å¤©ä¸‹** - splitå’Œmergeè§£å†³ä¸€åˆ‡
3. **ä»£ç çŸ­å¥½å†™** - æ¯”å…¶ä»–å¹³è¡¡æ ‘ç®€å•å¤ªå¤š
4. **åŠŸèƒ½è¶…å¼ºå¤§** - æ”¯æŒåŒºé—´æ“ä½œã€å¯æŒä¹…åŒ–ç­‰

### ğŸ† å­¦ä¹ è·¯çº¿

1. **æŒæ¡åŸºæœ¬æ¦‚å¿µ** - ç†è§£æƒé‡å’Œå¹³è¡¡çš„å…³ç³»
2. **ç†Ÿç»ƒsplit/merge** - è¿™æ˜¯FHQ-Treapçš„æ ¸å¿ƒ
3. **èƒŒè¯µç«èµ›æ¨¡æ¿** - P3369å’ŒP3391å¿…é¡»ç†Ÿç»ƒ
4. **æ‰©å±•é«˜çº§åº”ç”¨** - åŒºé—´æ“ä½œã€å¯æŒä¹…åŒ–ç­‰

### ğŸŒŸ ç«èµ›å»ºè®®

- ğŸ¯ **æ¯”èµ›å‰** - åŠ¡å¿…èƒŒç†ŸFHQ-Treapæ¨¡æ¿
- âš¡ **æ¯”èµ›ä¸­** - é‡åˆ°å¹³è¡¡æ ‘é¢˜ç›®ç›´æ¥å¥—ç”¨
- ğŸ† **æ¯”èµ›å** - æ€»ç»“ä¸åŒé¢˜å‹çš„å˜åŒ–æ¨¡å¼

### ğŸ® å®æˆ˜æé†’

1. **éšæœºç§å­** - è®°å¾—åˆå§‹åŒ–srand(time(0))
2. **è¾¹ç•Œæ¡ä»¶** - æ³¨æ„splitå’Œmergeçš„è¾¹ç•Œ
3. **å†…å­˜ç®¡ç†** - æ¯”èµ›ä¸­é€šå¸¸ä¸ç”¨æ‹…å¿ƒå†…å­˜æ³„æ¼
4. **è°ƒè¯•æŠ€å·§** - æ‰“å°æ ‘ç»“æ„å¸®åŠ©è°ƒè¯•

---

**ğŸŒ¸ "æŒæ¡äº†FHQ-Treapï¼Œä½ å°±æ‹¥æœ‰äº†OIç«èµ›ä¸­æœ€å¼ºå¤§çš„æ­¦å™¨ï¼" - ã‚¢ãƒªã‚¹, ãƒ¦ã‚¦ã‚«, ãƒ¦ã‚º**

*åƒç¦§å¹´ç§‘æŠ€å­¦é™¢ - åŠ©ä½ åœ¨OIçš„é“è·¯ä¸Šå‹‡æ”€é«˜å³°ï¼* 
</div> 