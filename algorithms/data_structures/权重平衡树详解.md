# ğŸŒ¸ æƒé‡å¹³è¡¡æ ‘è¯¦è§£
## *åƒç¦§å¹´ç§‘æŠ€å­¦é™¢ - ãƒ¦ã‚¦ã‚«æ•°æ®ç»“æ„ä¸“é¢˜*

*"æƒé‡å¹³è¡¡æ ‘åœ¨OIä¸­ç®€å•æ˜“å†™ï¼Œæ˜¯æœ€å—æ¬¢è¿çš„å¹³è¡¡æ ‘ä¹‹ä¸€ï¼"*

---

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#åŸºæœ¬æ¦‚å¿µ)
2. [FHQ-Treapè¯¦è§£](#fhq-treapè¯¦è§£)
3. [Weight Balanced Tree](#weight-balanced-tree)
4. [ç®—æ³•å®ç°](#ç®—æ³•å®ç°)
5. [åº”ç”¨ä¸ä¾‹é¢˜](#åº”ç”¨ä¸ä¾‹é¢˜)

---

## ğŸ¯ åŸºæœ¬æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯æƒé‡å¹³è¡¡æ ‘ï¼Ÿ

æƒé‡å¹³è¡¡æ ‘æ˜¯ä¸€ç±»é€šè¿‡èŠ‚ç‚¹æƒé‡æ¥ç»´æŠ¤å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ã€‚åœ¨OIä¸­ï¼Œæœ€å¸¸ç”¨çš„æœ‰ï¼š

1. **FHQ-Treap**ï¼šé€šè¿‡éšæœºä¼˜å…ˆçº§ç»´æŠ¤å¹³è¡¡
2. **Weight Balanced Tree**ï¼šé€šè¿‡å­æ ‘å¤§å°æ¯”ä¾‹ç»´æŠ¤å¹³è¡¡

### ğŸŒŸ æ ¸å¿ƒä¼˜åŠ¿

- **å®ç°ç®€å•**ï¼šä»£ç çŸ­ï¼Œæ˜“äºç†è§£
- **åŠŸèƒ½å¼ºå¤§**ï¼šæ”¯æŒåˆ†è£‚ã€åˆå¹¶ã€åŒºé—´æ“ä½œ
- **æ€§èƒ½ä¼˜ç§€**ï¼šæœŸæœ›æ—¶é—´å¤æ‚åº¦O(log n)
- **é€‚ç”¨èŒƒå›´å¹¿**ï¼šå¯è§£å†³å¤šç§é—®é¢˜

---

## ğŸš€ FHQ-Treapè¯¦è§£

### åŸºæœ¬åŸç†

FHQ-Treapï¼ˆæ— æ—‹Treapï¼‰é€šè¿‡**split**å’Œ**merge**æ“ä½œå®ç°æ‰€æœ‰åŠŸèƒ½ï¼š
- **split(root, k)**ï¼šå°†æ ‘åˆ†ä¸ºâ‰¤kå’Œ>kä¸¤éƒ¨åˆ†
- **merge(l, r)**ï¼šåˆå¹¶ä¸¤æ£µæ ‘ï¼ˆè¦æ±‚lçš„æ‰€æœ‰å€¼â‰¤rçš„æ‰€æœ‰å€¼ï¼‰

### æ ¸å¿ƒæ“ä½œ

```cpp
struct Node {
    int key, priority, size;
    Node *left, *right;
    
    Node(int k) : key(k), priority(rand()), size(1), left(nullptr), right(nullptr) {}
    
    void update() {
        size = 1;
        if (left) size += left->size;
        if (right) size += right->size;
    }
};

class FHQTreap {
private:
    Node* root;
    
    pair<Node*, Node*> split(Node* root, int key) {
        if (!root) return {nullptr, nullptr};
        
        if (root->key <= key) {
            auto [l, r] = split(root->right, key);
            root->right = l;
            root->update();
            return {root, r};
        } else {
            auto [l, r] = split(root->left, key);
            root->left = r;
            root->update();
            return {l, root};
        }
    }
    
    Node* merge(Node* l, Node* r) {
        if (!l || !r) return l ? l : r;
        
        if (l->priority > r->priority) {
            l->right = merge(l->right, r);
            l->update();
            return l;
        } else {
            r->left = merge(l, r->left);
            r->update();
            return r;
        }
    }
    
public:
    FHQTreap() : root(nullptr) { srand(time(nullptr)); }
    
    void insert(int key) {
        auto [l, r] = split(root, key);
        Node* newNode = new Node(key);
        root = merge(merge(l, newNode), r);
    }
    
    void remove(int key) {
        auto [l, temp] = split(root, key - 1);
        auto [mid, r] = split(temp, key);
        root = merge(l, r);
    }
    
    bool search(int key) {
        auto [l, temp] = split(root, key - 1);
        auto [mid, r] = split(temp, key);
        bool found = (mid != nullptr);
        root = merge(merge(l, mid), r);
        return found;
    }
    
    int kth(int k) {
        return kthHelper(root, k);
    }
    
private:
    int kthHelper(Node* root, int k) {
        if (!root) return -1;
        
        int leftSize = root->left ? root->left->size : 0;
        
        if (k <= leftSize) {
            return kthHelper(root->left, k);
        } else if (k == leftSize + 1) {
            return root->key;
        } else {
            return kthHelper(root->right, k - leftSize - 1);
        }
    }
    
public:
    int getRank(int key) {
        auto [l, r] = split(root, key - 1);
        int rank = (l ? l->size : 0) + 1;
        root = merge(l, r);
        return rank;
    }
};
```

### åŒºé—´æ“ä½œç‰ˆæœ¬

```cpp
class IntervalFHQTreap {
private:
    struct Node {
        int value, priority, size;
        bool reversed;
        Node *left, *right;
        
        Node(int v) : value(v), priority(rand()), size(1), 
                      reversed(false), left(nullptr), right(nullptr) {}
        
        void pushDown() {
            if (reversed) {
                swap(left, right);
                if (left) left->reversed ^= true;
                if (right) right->reversed ^= true;
                reversed = false;
            }
        }
        
        void update() {
            size = 1;
            if (left) size += left->size;
            if (right) size += right->size;
        }
    };
    
    Node* root;
    
    pair<Node*, Node*> splitByRank(Node* root, int k) {
        if (!root) return {nullptr, nullptr};
        
        root->pushDown();
        int leftSize = root->left ? root->left->size : 0;
        
        if (leftSize >= k) {
            auto [l, r] = splitByRank(root->left, k);
            root->left = r;
            root->update();
            return {l, root};
        } else {
            auto [l, r] = splitByRank(root->right, k - leftSize - 1);
            root->right = l;
            root->update();
            return {root, r};
        }
    }
    
    Node* merge(Node* l, Node* r) {
        if (!l || !r) return l ? l : r;
        
        if (l->priority > r->priority) {
            l->pushDown();
            l->right = merge(l->right, r);
            l->update();
            return l;
        } else {
            r->pushDown();
            r->left = merge(l, r->left);
            r->update();
            return r;
        }
    }
    
public:
    IntervalFHQTreap() : root(nullptr) { srand(time(nullptr)); }
    
    void insert(int pos, int value) {
        auto [l, r] = splitByRank(root, pos);
        Node* newNode = new Node(value);
        root = merge(merge(l, newNode), r);
    }
    
    void remove(int pos) {
        auto [l, temp] = splitByRank(root, pos - 1);
        auto [mid, r] = splitByRank(temp, 1);
        root = merge(l, r);
    }
    
    void reverse(int l, int r) {
        auto [left, temp] = splitByRank(root, l - 1);
        auto [mid, right] = splitByRank(temp, r - l + 1);
        
        if (mid) mid->reversed ^= true;
        
        root = merge(merge(left, mid), right);
    }
    
    int query(int pos) {
        auto [l, temp] = splitByRank(root, pos - 1);
        auto [mid, r] = splitByRank(temp, 1);
        
        int result = mid ? mid->value : -1;
        
        root = merge(merge(l, mid), r);
        return result;
    }
    
    void output() {
        outputHelper(root);
        cout << endl;
    }
    
private:
    void outputHelper(Node* root) {
        if (!root) return;
        
        root->pushDown();
        outputHelper(root->left);
        cout << root->value << " ";
        outputHelper(root->right);
    }
};
```

---

## ğŸŒ¸ Weight Balanced Tree

### åŸºæœ¬åŸç†

Weight Balanced Treeé€šè¿‡ç»´æŠ¤å­æ ‘å¤§å°æ¯”ä¾‹æ¥ä¿æŒå¹³è¡¡ï¼š
- å¯¹äºèŠ‚ç‚¹xï¼Œè¦æ±‚ size(x.left) â‰¤ Î± Ã— size(x) ä¸” size(x.right) â‰¤ Î± Ã— size(x)
- Î±é€šå¸¸å–0.75æˆ–0.8

### å®ç°æ¡†æ¶

```cpp
class WeightBalancedTree {
private:
    struct Node {
        int key, size;
        Node *left, *right;
        
        Node(int k) : key(k), size(1), left(nullptr), right(nullptr) {}
        
        void update() {
            size = 1;
            if (left) size += left->size;
            if (right) size += right->size;
        }
    };
    
    Node* root;
    const double alpha = 0.75;
    
    bool isBalanced(Node* node) {
        if (!node) return true;
        
        int leftSize = node->left ? node->left->size : 0;
        int rightSize = node->right ? node->right->size : 0;
        
        return leftSize <= alpha * node->size && rightSize <= alpha * node->size;
    }
    
    Node* rebuild(Node* root) {
        if (!root) return nullptr;
        
        vector<Node*> nodes;
        inorderCollect(root, nodes);
        return buildBalanced(nodes, 0, nodes.size() - 1);
    }
    
    void inorderCollect(Node* root, vector<Node*>& nodes) {
        if (!root) return;
        inorderCollect(root->left, nodes);
        nodes.push_back(root);
        inorderCollect(root->right, nodes);
    }
    
    Node* buildBalanced(vector<Node*>& nodes, int l, int r) {
        if (l > r) return nullptr;
        
        int mid = (l + r) / 2;
        Node* root = nodes[mid];
        
        root->left = buildBalanced(nodes, l, mid - 1);
        root->right = buildBalanced(nodes, mid + 1, r);
        
        root->update();
        return root;
    }
    
public:
    WeightBalancedTree() : root(nullptr) {}
    
    void insert(int key) {
        root = insertHelper(root, key);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ„
        if (!isBalanced(root)) {
            root = rebuild(root);
        }
    }
    
private:
    Node* insertHelper(Node* root, int key) {
        if (!root) return new Node(key);
        
        if (key < root->key) {
            root->left = insertHelper(root->left, key);
        } else if (key > root->key) {
            root->right = insertHelper(root->right, key);
        }
        
        root->update();
        return root;
    }
};
```

---

## ğŸ’» ç«èµ›æ¨¡æ¿

### FHQ-Treapç®€åŒ–ç‰ˆ

```cpp
struct Node {
    int key, priority, size;
    Node *l, *r;
    
    Node(int k) : key(k), priority(rand()), size(1), l(nullptr), r(nullptr) {}
    
    void update() {
        size = 1;
        if (l) size += l->size;
        if (r) size += r->size;
    }
};

Node* merge(Node* a, Node* b) {
    if (!a || !b) return a ? a : b;
    
    if (a->priority > b->priority) {
        a->r = merge(a->r, b);
        a->update();
        return a;
    } else {
        b->l = merge(a, b->l);
        b->update();
        return b;
    }
}

pair<Node*, Node*> split(Node* root, int key) {
    if (!root) return {nullptr, nullptr};
    
    if (root->key <= key) {
        auto [l, r] = split(root->r, key);
        root->r = l;
        root->update();
        return {root, r};
    } else {
        auto [l, r] = split(root->l, key);
        root->l = r;
        root->update();
        return {l, root};
    }
}

Node* root = nullptr;

void insert(int key) {
    auto [l, r] = split(root, key);
    Node* newNode = new Node(key);
    root = merge(merge(l, newNode), r);
}

void remove(int key) {
    auto [l, temp] = split(root, key - 1);
    auto [mid, r] = split(temp, key);
    root = merge(l, r);
}

int kth(Node* root, int k) {
    if (!root) return -1;
    
    int leftSize = root->l ? root->l->size : 0;
    
    if (k <= leftSize) {
        return kth(root->l, k);
    } else if (k == leftSize + 1) {
        return root->key;
    } else {
        return kth(root->r, k - leftSize - 1);
    }
}

int getRank(int key) {
    auto [l, r] = split(root, key - 1);
    int rank = (l ? l->size : 0) + 1;
    root = merge(l, r);
    return rank;
}
```

---

## ğŸ† åº”ç”¨ä¸ä¾‹é¢˜

### ç»å…¸ä¾‹é¢˜

#### 1. æ´›è°·P3369 - æ™®é€šå¹³è¡¡æ ‘

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int key, priority, size;
    Node *l, *r;
    
    Node(int k) : key(k), priority(rand()), size(1), l(nullptr), r(nullptr) {}
    
    void update() {
        size = 1;
        if (l) size += l->size;
        if (r) size += r->size;
    }
};

Node* merge(Node* a, Node* b) {
    if (!a || !b) return a ? a : b;
    
    if (a->priority > b->priority) {
        a->r = merge(a->r, b);
        a->update();
        return a;
    } else {
        b->l = merge(a, b->l);
        b->update();
        return b;
    }
}

pair<Node*, Node*> split(Node* root, int key) {
    if (!root) return {nullptr, nullptr};
    
    if (root->key <= key) {
        auto [l, r] = split(root->r, key);
        root->r = l;
        root->update();
        return {root, r};
    } else {
        auto [l, r] = split(root->l, key);
        root->l = r;
        root->update();
        return {l, root};
    }
}

Node* root = nullptr;

void insert(int key) {
    auto [l, r] = split(root, key);
    Node* newNode = new Node(key);
    root = merge(merge(l, newNode), r);
}

void remove(int key) {
    auto [l, temp] = split(root, key - 1);
    auto [mid, r] = split(temp, key);
    root = merge(l, r);
}

int kth(Node* root, int k) {
    if (!root) return -1;
    
    int leftSize = root->l ? root->l->size : 0;
    
    if (k <= leftSize) {
        return kth(root->l, k);
    } else if (k == leftSize + 1) {
        return root->key;
    } else {
        return kth(root->r, k - leftSize - 1);
    }
}

int getRank(int key) {
    auto [l, r] = split(root, key - 1);
    int rank = (l ? l->size : 0) + 1;
    root = merge(l, r);
    return rank;
}

int getPre(int key) {
    auto [l, r] = split(root, key - 1);
    int result = -1;
    
    if (l) {
        Node* current = l;
        while (current->r) current = current->r;
        result = current->key;
    }
    
    root = merge(l, r);
    return result;
}

int getNext(int key) {
    auto [l, r] = split(root, key);
    int result = -1;
    
    if (r) {
        Node* current = r;
        while (current->l) current = current->l;
        result = current->key;
    }
    
    root = merge(l, r);
    return result;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    while (n--) {
        int op, x;
        cin >> op >> x;
        
        switch (op) {
            case 1: insert(x); break;
            case 2: remove(x); break;
            case 3: cout << getRank(x) << "\n"; break;
            case 4: cout << kth(root, x) << "\n"; break;
            case 5: cout << getPre(x) << "\n"; break;
            case 6: cout << getNext(x) << "\n"; break;
        }
    }
    
    return 0;
}
```

#### 2. æ´›è°·P3391 - æ–‡è‰ºå¹³è¡¡æ ‘

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int value, priority, size;
    bool reversed;
    Node *l, *r;
    
    Node(int v) : value(v), priority(rand()), size(1), 
                  reversed(false), l(nullptr), r(nullptr) {}
    
    void pushDown() {
        if (reversed) {
            swap(l, r);
            if (l) l->reversed ^= true;
            if (r) r->reversed ^= true;
            reversed = false;
        }
    }
    
    void update() {
        size = 1;
        if (l) size += l->size;
        if (r) size += r->size;
    }
};

Node* merge(Node* a, Node* b) {
    if (!a || !b) return a ? a : b;
    
    if (a->priority > b->priority) {
        a->pushDown();
        a->r = merge(a->r, b);
        a->update();
        return a;
    } else {
        b->pushDown();
        b->l = merge(a, b->l);
        b->update();
        return b;
    }
}

pair<Node*, Node*> splitByRank(Node* root, int k) {
    if (!root) return {nullptr, nullptr};
    
    root->pushDown();
    int leftSize = root->l ? root->l->size : 0;
    
    if (leftSize >= k) {
        auto [l, r] = splitByRank(root->l, k);
        root->l = r;
        root->update();
        return {l, root};
    } else {
        auto [l, r] = splitByRank(root->r, k - leftSize - 1);
        root->r = l;
        root->update();
        return {root, r};
    }
}

Node* root = nullptr;

void reverse(int l, int r) {
    auto [left, temp] = splitByRank(root, l - 1);
    auto [mid, right] = splitByRank(temp, r - l + 1);
    
    if (mid) mid->reversed ^= true;
    
    root = merge(merge(left, mid), right);
}

void output(Node* root) {
    if (!root) return;
    
    root->pushDown();
    output(root->l);
    cout << root->value << " ";
    output(root->r);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n >> m;
    
    // åˆå§‹åŒ–åºåˆ—
    for (int i = 1; i <= n; i++) {
        Node* newNode = new Node(i);
        root = merge(root, newNode);
    }
    
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        reverse(l, r);
    }
    
    output(root);
    cout << endl;
    
    return 0;
}
```

### ğŸ¯ å­¦ä¹ å»ºè®®

1. **æŒæ¡split/merge**ï¼šè¿™æ˜¯FHQ-Treapçš„æ ¸å¿ƒæ“ä½œ
2. **ç†è§£æ‡’æƒ°æ ‡è®°**ï¼šç”¨äºåŒºé—´æ“ä½œçš„å…³é”®æŠ€å·§
3. **ç»ƒä¹ ç»å…¸é¢˜ç›®**ï¼šä»æ™®é€šå¹³è¡¡æ ‘åˆ°æ–‡è‰ºå¹³è¡¡æ ‘
4. **çµæ´»è¿ç”¨**ï¼šæ ¹æ®é¢˜ç›®éœ€æ±‚è°ƒæ•´å®ç°

---

<div align="center">

### ğŸŒ¸ ç‰¹åˆ«é¸£è°¢

**æ„Ÿè°¢åƒç¦§å¹´ç§‘æŠ€å­¦é™¢æ•°æ®ç»“æ„ç ”ç©¶å°ç»„ï¼**

> *"æƒé‡å¹³è¡¡æ ‘ç®€å•æ˜“æ‡‚ï¼ŒåŠŸèƒ½å¼ºå¤§ï¼Œæ˜¯OIç«èµ›ä¸­çš„å¾—åŠ›åŠ©æ‰‹ï¼"*
>
> â€” **ãƒ¦ã‚¦ã‚«**

*ğŸŒ¸ ç®€å•çš„ä»£ç ï¼Œå¼ºå¤§çš„åŠŸèƒ½ï¼Œè¿™å°±æ˜¯æƒé‡å¹³è¡¡æ ‘çš„é­…åŠ›ï¼*

</div> 