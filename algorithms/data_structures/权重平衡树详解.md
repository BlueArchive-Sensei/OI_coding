# üå∏ ÊùÉÈáçÂπ≥Ë°°Ê†ëËØ¶Ëß£
## *ÂçÉÁ¶ßÂπ¥ÁßëÊäÄÂ≠¶Èô¢ - „É¶„Ç¶„Ç´Êï∞ÊçÆÁªìÊûÑ‰∏ìÈ¢ò*

*"ÊùÉÈáçÂπ≥Ë°°Ê†ëÂú®OI‰∏≠ÁÆÄÂçïÊòìÂÜôÔºåÊòØÊúÄÂèóÊ¨¢ËøéÁöÑÂπ≥Ë°°Ê†ë‰πã‰∏ÄÔºÅ"*

---

## üìö ÁõÆÂΩï

1. [Âü∫Êú¨Ê¶ÇÂøµ](#Âü∫Êú¨Ê¶ÇÂøµ)
2. [FHQ-TreapËØ¶Ëß£](#fhq-treapËØ¶Ëß£)
3. [Weight Balanced Tree](#weight-balanced-tree)
4. [ÁÆóÊ≥ïÂÆûÁé∞](#ÁÆóÊ≥ïÂÆûÁé∞)
5. [Â∫îÁî®‰∏é‰æãÈ¢ò](#Â∫îÁî®‰∏é‰æãÈ¢ò)

---

## üéØ Âü∫Êú¨Ê¶ÇÂøµ

### ‰ªÄ‰πàÊòØÊùÉÈáçÂπ≥Ë°°Ê†ëÔºü

ÊùÉÈáçÂπ≥Ë°°Ê†ëÊòØ‰∏ÄÁ±ªÈÄöËøáËäÇÁÇπÊùÉÈáçÊù•Áª¥Êä§Âπ≥Ë°°ÁöÑ‰∫åÂèâÊêúÁ¥¢Ê†ë„ÄÇÂú®OI‰∏≠ÔºåÊúÄÂ∏∏Áî®ÁöÑÊúâÔºö

1. **FHQ-Treap**ÔºöÈÄöËøáÈöèÊú∫‰ºòÂÖàÁ∫ßÁª¥Êä§Âπ≥Ë°°
2. **Weight Balanced Tree**ÔºöÈÄöËøáÂ≠êÊ†ëÂ§ßÂ∞èÊØî‰æãÁª¥Êä§Âπ≥Ë°°

### üåü Ê†∏ÂøÉ‰ºòÂäø

- **ÂÆûÁé∞ÁÆÄÂçï**Ôºö‰ª£Á†ÅÁü≠ÔºåÊòì‰∫éÁêÜËß£
- **ÂäüËÉΩÂº∫Â§ß**ÔºöÊîØÊåÅÂàÜË£Ç„ÄÅÂêàÂπ∂„ÄÅÂå∫Èó¥Êìç‰Ωú
- **ÊÄßËÉΩ‰ºòÁßÄ**ÔºöÊúüÊúõÊó∂Èó¥Â§çÊùÇÂ∫¶O(log n)
- **ÈÄÇÁî®ËåÉÂõ¥Âπø**ÔºöÂèØËß£ÂÜ≥Â§öÁßçÈóÆÈ¢ò

---

## üöÄ FHQ-TreapËØ¶Ëß£

### Âü∫Êú¨ÂéüÁêÜ

FHQ-TreapÔºàÊó†ÊóãTreapÔºâÈÄöËøá**split**Âíå**merge**Êìç‰ΩúÂÆûÁé∞ÊâÄÊúâÂäüËÉΩÔºö
- **split(root, k)**ÔºöÂ∞ÜÊ†ëÂàÜ‰∏∫‚â§kÂíå>k‰∏§ÈÉ®ÂàÜ
- **merge(l, r)**ÔºöÂêàÂπ∂‰∏§Ê£µÊ†ëÔºàË¶ÅÊ±ÇlÁöÑÊâÄÊúâÂÄº‚â§rÁöÑÊâÄÊúâÂÄºÔºâ

### Ê†∏ÂøÉÊìç‰Ωú

```cpp
struct Node {
    int key, priority, size;
    Node *left, *right;
    
    Node(int k) : key(k), priority(rand()), size(1), left(nullptr), right(nullptr) {}
    
    void update() {
        size = 1;
        if (left) size += left->size;
        if (right) size += right->size;
    }
};

class FHQTreap {
private:
    Node* root;
    
    pair<Node*, Node*> split(Node* root, int key) {
        if (!root) return {nullptr, nullptr};
        
        if (root->key <= key) {
            auto [l, r] = split(root->right, key);
            root->right = l;
            root->update();
            return {root, r};
        } else {
            auto [l, r] = split(root->left, key);
            root->left = r;
            root->update();
            return {l, root};
        }
    }
    
    Node* merge(Node* l, Node* r) {
        if (!l || !r) return l ? l : r;
        
        if (l->priority > r->priority) {
            l->right = merge(l->right, r);
            l->update();
            return l;
        } else {
            r->left = merge(l, r->left);
            r->update();
            return r;
        }
    }
    
public:
    FHQTreap() : root(nullptr) { srand(time(nullptr)); }
    
    void insert(int key) {
        auto [l, r] = split(root, key);
        Node* newNode = new Node(key);
        root = merge(merge(l, newNode), r);
    }
    
    void remove(int key) {
        auto [l, temp] = split(root, key - 1);
        auto [mid, r] = split(temp, key);
        root = merge(l, r);
    }
    
    bool search(int key) {
        auto [l, temp] = split(root, key - 1);
        auto [mid, r] = split(temp, key);
        bool found = (mid != nullptr);
        root = merge(merge(l, mid), r);
        return found;
    }
    
    int kth(int k) {
        return kthHelper(root, k);
    }
    
private:
    int kthHelper(Node* root, int k) {
        if (!root) return -1;
        
        int leftSize = root->left ? root->left->size : 0;
        
        if (k <= leftSize) {
            return kthHelper(root->left, k);
        } else if (k == leftSize + 1) {
            return root->key;
        } else {
            return kthHelper(root->right, k - leftSize - 1);
        }
    }
    
public:
    int getRank(int key) {
        auto [l, r] = split(root, key - 1);
        int rank = (l ? l->size : 0) + 1;
        root = merge(l, r);
        return rank;
    }
};
```

### Âå∫Èó¥Êìç‰ΩúÁâàÊú¨

```cpp
class IntervalFHQTreap {
private:
    struct Node {
        int value, priority, size;
        bool reversed;
        Node *left, *right;
        
        Node(int v) : value(v), priority(rand()), size(1), 
                      reversed(false), left(nullptr), right(nullptr) {}
        
        void pushDown() {
            if (reversed) {
                swap(left, right);
                if (left) left->reversed ^= true;
                if (right) right->reversed ^= true;
                reversed = false;
            }
        }
        
        void update() {
            size = 1;
            if (left) size += left->size;
            if (right) size += right->size;
        }
    };
    
    Node* root;
    
    pair<Node*, Node*> splitByRank(Node* root, int k) {
        if (!root) return {nullptr, nullptr};
        
        root->pushDown();
        int leftSize = root->left ? root->left->size : 0;
        
        if (leftSize >= k) {
            auto [l, r] = splitByRank(root->left, k);
            root->left = r;
            root->update();
            return {l, root};
        } else {
            auto [l, r] = splitByRank(root->right, k - leftSize - 1);
            root->right = l;
            root->update();
            return {root, r};
        }
    }
    
    Node* merge(Node* l, Node* r) {
        if (!l || !r) return l ? l : r;
        
        if (l->priority > r->priority) {
            l->pushDown();
            l->right = merge(l->right, r);
            l->update();
            return l;
        } else {
            r->pushDown();
            r->left = merge(l, r->left);
            r->update();
            return r;
        }
    }
    
public:
    IntervalFHQTreap() : root(nullptr) { srand(time(nullptr)); }
    
    void insert(int pos, int value) {
        auto [l, r] = splitByRank(root, pos);
        Node* newNode = new Node(value);
        root = merge(merge(l, newNode), r);
    }
    
    void remove(int pos) {
        auto [l, temp] = splitByRank(root, pos - 1);
        auto [mid, r] = splitByRank(temp, 1);
        root = merge(l, r);
    }
    
    void reverse(int l, int r) {
        auto [left, temp] = splitByRank(root, l - 1);
        auto [mid, right] = splitByRank(temp, r - l + 1);
        
        if (mid) mid->reversed ^= true;
        
        root = merge(merge(left, mid), right);
    }
    
    int query(int pos) {
        auto [l, temp] = splitByRank(root, pos - 1);
        auto [mid, r] = splitByRank(temp, 1);
        
        int result = mid ? mid->value : -1;
        
        root = merge(merge(l, mid), r);
        return result;
    }
    
    void output() {
        outputHelper(root);
        cout << endl;
    }
    
private:
    void outputHelper(Node* root) {
        if (!root) return;
        
        root->pushDown();
        outputHelper(root->left);
        cout << root->value << " ";
        outputHelper(root->right);
    }
};
```

---

## üå∏ Weight Balanced Tree

### Âü∫Êú¨ÂéüÁêÜ

Weight Balanced TreeÈÄöËøáÁª¥Êä§Â≠êÊ†ëÂ§ßÂ∞èÊØî‰æãÊù•‰øùÊåÅÂπ≥Ë°°Ôºö
- ÂØπ‰∫éËäÇÁÇπxÔºåË¶ÅÊ±Ç size(x.left) ‚â§ Œ± √ó size(x) ‰∏î size(x.right) ‚â§ Œ± √ó size(x)
- Œ±ÈÄöÂ∏∏Âèñ0.75Êàñ0.8

### ÂÆûÁé∞Ê°ÜÊû∂

```cpp
class WeightBalancedTree {
private:
    struct Node {
        int key, size;
        Node *left, *right;
        
        Node(int k) : key(k), size(1), left(nullptr), right(nullptr) {}
        
        void update() {
            size = 1;
            if (left) size += left->size;
            if (right) size += right->size;
        }
    };
    
    Node* root;
    const double alpha = 0.75;
    
    bool isBalanced(Node* node) {
        if (!node) return true;
        
        int leftSize = node->left ? node->left->size : 0;
        int rightSize = node->right ? node->right->size : 0;
        
        return leftSize <= alpha * node->size && rightSize <= alpha * node->size;
    }
    
    Node* rebuild(Node* root) {
        if (!root) return nullptr;
        
        vector<Node*> nodes;
        inorderCollect(root, nodes);
        return buildBalanced(nodes, 0, nodes.size() - 1);
    }
    
    void inorderCollect(Node* root, vector<Node*>& nodes) {
        if (!root) return;
        inorderCollect(root->left, nodes);
        nodes.push_back(root);
        inorderCollect(root->right, nodes);
    }
    
    Node* buildBalanced(vector<Node*>& nodes, int l, int r) {
        if (l > r) return nullptr;
        
        int mid = (l + r) / 2;
        Node* root = nodes[mid];
        
        root->left = buildBalanced(nodes, l, mid - 1);
        root->right = buildBalanced(nodes, mid + 1, r);
        
        root->update();
        return root;
    }
    
public:
    WeightBalancedTree() : root(nullptr) {}
    
    void insert(int key) {
        root = insertHelper(root, key);
        
        // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÈáçÊûÑ
        if (!isBalanced(root)) {
            root = rebuild(root);
        }
    }
    
private:
    Node* insertHelper(Node* root, int key) {
        if (!root) return new Node(key);
        
        if (key < root->key) {
            root->left = insertHelper(root->left, key);
        } else if (key > root->key) {
            root->right = insertHelper(root->right, key);
        }
        
        root->update();
        return root;
    }
};
```

---

## üíª Á´ûËµõÊ®°Êùø

### FHQ-TreapÁÆÄÂåñÁâà

```cpp
struct Node {
    int key, priority, size;
    Node *l, *r;
    
    Node(int k) : key(k), priority(rand()), size(1), l(nullptr), r(nullptr) {}
    
    void update() {
        size = 1;
        if (l) size += l->size;
        if (r) size += r->size;
    }
};

Node* merge(Node* a, Node* b) {
    if (!a || !b) return a ? a : b;
    
    if (a->priority > b->priority) {
        a->r = merge(a->r, b);
        a->update();
        return a;
    } else {
        b->l = merge(a, b->l);
        b->update();
        return b;
    }
}

pair<Node*, Node*> split(Node* root, int key) {
    if (!root) return {nullptr, nullptr};
    
    if (root->key <= key) {
        auto [l, r] = split(root->r, key);
        root->r = l;
        root->update();
        return {root, r};
    } else {
        auto [l, r] = split(root->l, key);
        root->l = r;
        root->update();
        return {l, root};
    }
}

Node* root = nullptr;

void insert(int key) {
    auto [l, r] = split(root, key);
    Node* newNode = new Node(key);
    root = merge(merge(l, newNode), r);
}

void remove(int key) {
    auto [l, temp] = split(root, key - 1);
    auto [mid, r] = split(temp, key);
    root = merge(l, r);
}

int kth(Node* root, int k) {
    if (!root) return -1;
    
    int leftSize = root->l ? root->l->size : 0;
    
    if (k <= leftSize) {
        return kth(root->l, k);
    } else if (k == leftSize + 1) {
        return root->key;
    } else {
        return kth(root->r, k - leftSize - 1);
    }
}

int getRank(int key) {
    auto [l, r] = split(root, key - 1);
    int rank = (l ? l->size : 0) + 1;
    root = merge(l, r);
    return rank;
}
```

---

## üèÜ Â∫îÁî®‰∏é‰æãÈ¢ò

### ÁªèÂÖ∏‰æãÈ¢ò

#### 1. Ê¥õË∞∑P3369 - ÊôÆÈÄöÂπ≥Ë°°Ê†ë

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int key, priority, size;
    Node *l, *r;
    
    Node(int k) : key(k), priority(rand()), size(1), l(nullptr), r(nullptr) {}
    
    void update() {
        size = 1;
        if (l) size += l->size;
        if (r) size += r->size;
    }
};

Node* merge(Node* a, Node* b) {
    if (!a || !b) return a ? a : b;
    
    if (a->priority > b->priority) {
        a->r = merge(a->r, b);
        a->update();
        return a;
    } else {
        b->l = merge(a, b->l);
        b->update();
        return b;
    }
}

pair<Node*, Node*> split(Node* root, int key) {
    if (!root) return {nullptr, nullptr};
    
    if (root->key <= key) {
        auto [l, r] = split(root->r, key);
        root->r = l;
        root->update();
        return {root, r};
    } else {
        auto [l, r] = split(root->l, key);
        root->l = r;
        root->update();
        return {l, root};
    }
}

Node* root = nullptr;

void insert(int key) {
    auto [l, r] = split(root, key);
    Node* newNode = new Node(key);
    root = merge(merge(l, newNode), r);
}

void remove(int key) {
    auto [l, temp] = split(root, key - 1);
    auto [mid, r] = split(temp, key);
    root = merge(l, r);
}

int kth(Node* root, int k) {
    if (!root) return -1;
    
    int leftSize = root->l ? root->l->size : 0;
    
    if (k <= leftSize) {
        return kth(root->l, k);
    } else if (k == leftSize + 1) {
        return root->key;
    } else {
        return kth(root->r, k - leftSize - 1);
    }
}

int getRank(int key) {
    auto [l, r] = split(root, key - 1);
    int rank = (l ? l->size : 0) + 1;
    root = merge(l, r);
    return rank;
}

int getPre(int key) {
    auto [l, r] = split(root, key - 1);
    int result = -1;
    
    if (l) {
        Node* current = l;
        while (current->r) current = current->r;
        result = current->key;
    }
    
    root = merge(l, r);
    return result;
}

int getNext(int key) {
    auto [l, r] = split(root, key);
    int result = -1;
    
    if (r) {
        Node* current = r;
        while (current->l) current = current->l;
        result = current->key;
    }
    
    root = merge(l, r);
    return result;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    while (n--) {
        int op, x;
        cin >> op >> x;
        
        switch (op) {
            case 1: insert(x); break;
            case 2: remove(x); break;
            case 3: cout << getRank(x) << "\n"; break;
            case 4: cout << kth(root, x) << "\n"; break;
            case 5: cout << getPre(x) << "\n"; break;
            case 6: cout << getNext(x) << "\n"; break;
        }
    }
    
    return 0;
}
```

#### 2. Ê¥õË∞∑P3391 - ÊñáËâ∫Âπ≥Ë°°Ê†ë

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int value, priority, size;
    bool reversed;
    Node *l, *r;
    
    Node(int v) : value(v), priority(rand()), size(1), 
                  reversed(false), l(nullptr), r(nullptr) {}
    
    void pushDown() {
        if (reversed) {
            swap(l, r);
            if (l) l->reversed ^= true;
            if (r) r->reversed ^= true;
            reversed = false;
        }
    }
    
    void update() {
        size = 1;
        if (l) size += l->size;
        if (r) size += r->size;
    }
};

Node* merge(Node* a, Node* b) {
    if (!a || !b) return a ? a : b;
    
    if (a->priority > b->priority) {
        a->pushDown();
        a->r = merge(a->r, b);
        a->update();
        return a;
    } else {
        b->pushDown();
        b->l = merge(a, b->l);
        b->update();
        return b;
    }
}

pair<Node*, Node*> splitByRank(Node* root, int k) {
    if (!root) return {nullptr, nullptr};
    
    root->pushDown();
    int leftSize = root->l ? root->l->size : 0;
    
    if (leftSize >= k) {
        auto [l, r] = splitByRank(root->l, k);
        root->l = r;
        root->update();
        return {l, root};
    } else {
        auto [l, r] = splitByRank(root->r, k - leftSize - 1);
        root->r = l;
        root->update();
        return {root, r};
    }
}

Node* root = nullptr;

void reverse(int l, int r) {
    auto [left, temp] = splitByRank(root, l - 1);
    auto [mid, right] = splitByRank(temp, r - l + 1);
    
    if (mid) mid->reversed ^= true;
    
    root = merge(merge(left, mid), right);
}

void output(Node* root) {
    if (!root) return;
    
    root->pushDown();
    output(root->l);
    cout << root->value << " ";
    output(root->r);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n >> m;
    
    // ÂàùÂßãÂåñÂ∫èÂàó
    for (int i = 1; i <= n; i++) {
        Node* newNode = new Node(i);
        root = merge(root, newNode);
    }
    
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        reverse(l, r);
    }
    
    output(root);
    cout << endl;
    
    return 0;
}
```

### üéØ Â≠¶‰π†Âª∫ËÆÆ

1. **ÊéåÊè°split/merge**ÔºöËøôÊòØFHQ-TreapÁöÑÊ†∏ÂøÉÊìç‰Ωú
2. **ÁêÜËß£ÊáíÊÉ∞Ê†áËÆ∞**ÔºöÁî®‰∫éÂå∫Èó¥Êìç‰ΩúÁöÑÂÖ≥ÈîÆÊäÄÂ∑ß
3. **ÁªÉ‰π†ÁªèÂÖ∏È¢òÁõÆ**Ôºö‰ªéÊôÆÈÄöÂπ≥Ë°°Ê†ëÂà∞ÊñáËâ∫Âπ≥Ë°°Ê†ë
4. **ÁÅµÊ¥ªËøêÁî®**ÔºöÊ†πÊçÆÈ¢òÁõÆÈúÄÊ±ÇË∞ÉÊï¥ÂÆûÁé∞

---

<div align="center">

### üå∏ ÁâπÂà´È∏£Ë∞¢

**ÊÑüË∞¢ÂçÉÁ¶ßÂπ¥ÁßëÊäÄÂ≠¶Èô¢Êï∞ÊçÆÁªìÊûÑÁ†îÁ©∂Â∞èÁªÑÔºÅ**

> *"ÊùÉÈáçÂπ≥Ë°°Ê†ëÁÆÄÂçïÊòìÊáÇÔºåÂäüËÉΩÂº∫Â§ßÔºåÊòØOIÁ´ûËµõ‰∏≠ÁöÑÂæóÂäõÂä©ÊâãÔºÅ"*
>
> ‚Äî **„É¶„Ç¶„Ç´**

*üå∏ ÁÆÄÂçïÁöÑ‰ª£Á†ÅÔºåÂº∫Â§ßÁöÑÂäüËÉΩÔºåËøôÂ∞±ÊòØÊùÉÈáçÂπ≥Ë°°Ê†ëÁöÑÈ≠ÖÂäõÔºÅ*

</div> 