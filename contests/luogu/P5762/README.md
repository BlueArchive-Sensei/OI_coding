# P5762 [NOI1997] 卫星覆盖 - 完整题解

## 🎯 题目信息

- **题目来源**: 洛谷 NOI1997
- **题目链接**: [P5762 [NOI1997] 卫星覆盖](https://www.luogu.com.cn/problem/P5762)
- **难度**: NOI/NOI+
- **算法标签**: 计算几何、坐标离散化、三维空间处理

## 📝 题目描述

SERCOI组织研制了新型卫星SERCOI-308，每个卫星可以覆盖一个立方体空间。
- 卫星位于立方体中心
- 用四元组(x,y,z,r)描述卫星：(x,y,z)是中心坐标，r是中心到各面的距离
- 立方体覆盖范围：[x-r, x+r] × [y-r, y+r] × [z-r, z+r]
- 多个卫星的覆盖区域可能重叠
- 求所有卫星覆盖的**总体积**（扣除重叠部分）

### 数据范围
- 1 ≤ N ≤ 100（卫星数量）
- -1000 ≤ x,y,z ≤ 1000
- 1 ≤ r ≤ 200

### 样例
```
输入：
3
0 0 0 3
1 -1 0 1
19 3 5 6

输出：
1944
```

---

## 🧮 问题分析

### 📊 问题本质

这是一个**三维空间中求多个长方体并集体积**的经典计算几何问题。

**关键观察**：
1. 每个卫星覆盖一个轴对齐的立方体
2. 需要计算所有立方体的并集体积
3. 直接计算并集很困难，可以通过坐标离散化简化

### 🔄 算法思路

**核心思想**：坐标离散化 + 暴力枚举

**步骤**：
1. **收集边界坐标**：将所有立方体的边界坐标收集起来
2. **坐标离散化**：对x、y、z坐标分别去重排序
3. **空间划分**：用离散化后的坐标将空间划分为小立方体
4. **覆盖判断**：对每个小立方体，判断是否被至少一个卫星覆盖
5. **体积累加**：累加所有被覆盖的小立方体的体积

---

## 🏗️ 算法实现

### 🎯 坐标离散化

```cpp
// 收集所有立方体的边界坐标
set<int> x_coords, y_coords, z_coords;

for (int i = 0; i < n; i++) {
    x_coords.insert(satellites[i].x - satellites[i].r);  // 左边界
    x_coords.insert(satellites[i].x + satellites[i].r);  // 右边界
    y_coords.insert(satellites[i].y - satellites[i].r);
    y_coords.insert(satellites[i].y + satellites[i].r);
    z_coords.insert(satellites[i].z - satellites[i].r);
    z_coords.insert(satellites[i].z + satellites[i].r);
}

// 转换为有序数组
vector<int> x_arr(x_coords.begin(), x_coords.end());
vector<int> y_arr(y_coords.begin(), y_coords.end());
vector<int> z_arr(z_coords.begin(), z_coords.end());
```

### 🔍 小立方体枚举与判断

```cpp
long long total_volume = 0;

// 枚举所有可能的小立方体（相邻坐标间的区域）
for (int i = 0; i < x_arr.size() - 1; i++) {
    for (int j = 0; j < y_arr.size() - 1; j++) {
        for (int k = 0; k < z_arr.size() - 1; k++) {
            // 当前小立方体范围：[x1,x2] × [y1,y2] × [z1,z2]
            int x1 = x_arr[i], x2 = x_arr[i + 1];
            int y1 = y_arr[j], y2 = y_arr[j + 1];
            int z1 = z_arr[k], z2 = z_arr[k + 1];
            
            // 检查是否被至少一个卫星覆盖
            bool covered = false;
            for (int s = 0; s < n; s++) {
                if (isContained(x1, x2, y1, y2, z1, z2, satellites[s])) {
                    covered = true;
                    break;
                }
            }
            
            if (covered) {
                total_volume += (long long)(x2-x1) * (y2-y1) * (z2-z1);
            }
        }
    }
}
```

### ✨ 包含判断

```cpp
// 判断小立方体[x1,x2]×[y1,y2]×[z1,z2]是否完全被卫星覆盖
bool isContained(int x1, int x2, int y1, int y2, int z1, int z2, const Satellite& sat) {
    return (x1 >= sat.x - sat.r && x2 <= sat.x + sat.r &&
            y1 >= sat.y - sat.r && y2 <= sat.y + sat.r &&
            z1 >= sat.z - sat.r && z2 <= sat.z + sat.r);
}
```

---

## 📊 算法分析

### ⏰ 时间复杂度

**分析**：
- 坐标离散化：O(N log N)
- 三重循环枚举小立方体：O(N³)（每个维度最多2N个坐标）
- 每个小立方体检查N个卫星：O(N)
- **总复杂度**：O(N⁴)

**实际效果**：
- N ≤ 100，N⁴ ≤ 10⁸，在时间限制内可以通过
- 实际运行时间会更短，因为很多小立方体不会被覆盖

### 💾 空间复杂度

**分析**：
- 存储卫星信息：O(N)
- 坐标离散化：O(N)
- **总复杂度**：O(N)

---

## 🎪 正确性证明

### 📏 离散化正确性

**定理1**：坐标离散化不会改变并集体积的计算结果。

**证明**：
设所有立方体的边界坐标集合为 {x₁, x₂, ..., xₖ}，排序后为 x₁ < x₂ < ... < xₖ。

对于任意相邻区间 [xᵢ, xᵢ₊₁]，其中的任意点都具有相同的"被覆盖"属性：
- 要么整个区间都被某些立方体覆盖
- 要么整个区间都不被任何立方体覆盖

因此，我们只需要判断每个离散化后的小立方体是否被覆盖，累加它们的体积即可。 ∎

### 🎯 覆盖判断正确性

**定理2**：小立方体完全包含判断的正确性。

**证明**：
对于小立方体 [x₁,x₂] × [y₁,y₂] × [z₁,z₂] 和卫星立方体 [sx-r, sx+r] × [sy-r, sy+r] × [sz-r, sz+r]：

小立方体被卫星覆盖 ⟺ 小立方体完全包含在卫星立方体内

⟺ x₁ ≥ sx-r ∧ x₂ ≤ sx+r ∧ y₁ ≥ sy-r ∧ y₂ ≤ sy+r ∧ z₁ ≥ sz-r ∧ z₂ ≤ sz+r

这正是我们代码中的判断条件。 ∎

---

## 🔍 样例验证

### 输入分析
```
3
0 0 0 3    # 立方体1: [-3,3] × [-3,3] × [-3,3]，体积 = 6³ = 216
1 -1 0 1   # 立方体2: [0,2] × [-2,0] × [-1,1]，体积 = 2×2×2 = 8  
19 3 5 6   # 立方体3: [13,25] × [-3,9] × [-1,11]，体积 = 12×12×12 = 1728
```

### 覆盖关系分析
- 立方体1和立方体2有重叠：立方体2的部分区域 [0,2] × [-2,0] × [-1,1] 与立方体1重叠
- 立方体3与前两个立方体没有重叠（距离太远）

### 计算验证
- 立方体1体积：216
- 立方体2体积：8（但与立方体1重叠部分需要扣除）
- 立方体3体积：1728
- 重叠部分体积：立方体2完全包含在立方体1内，所以重叠体积为8

**总体积** = 216 + 8 + 1728 - 8 = 1944 ✓

---

## ⚡ 优化技巧与注意事项

### 🎯 实现要点

1. **数据类型选择**：
   ```cpp
   long long total_volume = 0;  // 防止溢出
   long long volume = (long long)(x2-x1) * (y2-y1) * (z2-z1);
   ```

2. **边界处理**：
   ```cpp
   // 确保循环边界正确
   for (int i = 0; i < (int)x_arr.size() - 1; i++)
   ```

3. **早期终止优化**：
   ```cpp
   // 找到一个覆盖就可以跳出
   if (covered) break;
   ```

### 🚀 可能的优化方向

1. **剪枝优化**：预先计算每个卫星的覆盖范围，避免不必要的判断
2. **空间压缩**：如果坐标范围很大，可以考虑更高效的存储方式
3. **并行计算**：三重循环中的计算可以并行化

---

## 🏆 算法总结

### 🌟 核心思想

这道题展示了**坐标离散化**在计算几何中的重要应用：
1. **问题转化**：连续空间问题 → 离散空间问题
2. **维度分离**：三维问题 → 三个一维问题的组合
3. **暴力优化**：通过离散化将无限空间压缩为有限空间

### 📈 学习价值

- **计算几何基础**：轴对齐矩形/立方体的处理
- **坐标离散化**：处理大坐标范围的经典技巧
- **空间复杂度权衡**：用时间换空间的优化思路
- **三维空间思维**：从二维扩展到三维的能力

### 💡 相关问题

类似的问题模式：
- 二维平面上的矩形并集面积
- 多维空间中的超矩形并集体积
- 区间并集长度计算
- 扫描线算法的应用

---

## 📁 文件说明

- `P5762.cpp` - 坐标离散化解法
- `README.md` - 完整题解与算法分析
- `test_input.txt` - 测试样例

---

*"计算几何的魅力在于将复杂的空间关系转化为简洁的数学表达"* 🌟  
*三维空间处理的完整解决方案* ✨ 