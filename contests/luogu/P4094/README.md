# P4094 [HEOI2016/TJOI2016] 字符串 - 题解

## 🎯 题目信息

- **题目来源**: 洛谷 HEOI2016/TJOI2016
- **题目链接**: [P4094 [HEOI2016/TJOI2016] 字符串](https://www.luogu.com.cn/problem/P4094)
- **难度**: NOI/NOI+/CTSC
- **算法标签**: 后缀数组、ST表、最长公共前缀(LCP)、**主席树**、**二分答案**

## 📝 题目描述

给定一个长度为 n 的字符串 s，和 m 个问题。

每个问题均有 a,b,c,d 四个参数，问你子串 s[a..b] 的所有子串和 s[c..d] 的最长公共前缀的长度的最大值是多少？

### 输入格式
```
第一行：n m
第二行：字符串 s
接下来 m 行：每行四个整数 a b c d
```

### 输出格式
```
对于每个问题，输出一个整数，表示最大的最长公共前缀长度
```

### 数据范围
- 对于 10% 的数据，1 ≤ n,m ≤ 300
- 对于 40% 的数据，1 ≤ n,m ≤ 3,000，字符串中仅有 'a','b'
- 对于 100% 的数据，1 ≤ n,m ≤ 100,000，字符串中仅有小写英文字母，a ≤ b，c ≤ d，1 ≤ a,b,c,d ≤ n

## 💡 **最终解法：二分答案 + 后缀数组 + 主席树**

这道题的精妙之处在于**问题转化**和**可二分性发现**！

### 🔑 核心洞察

**关键发现**：设答案为 `mid`，如果 `mid` 可行，那么任意比 `mid` 小的数也可行。

**问题转化**：
1. **原问题**：求最大的LCP长度
2. **转化为判定问题**：长度为 `mid` 的LCP是否存在？
3. **进一步转化**：是否存在后缀S满足：
   - 开头在 `[a, b-mid+1]` 中
   - `lcp(S, c) ≥ mid`

### 🚀 算法流程

#### 1. 预处理阶段
```cpp
// 构建后缀数组和height数组
sa.buildSA();

// 构建ST表，支持O(1)查询LCP
st.init();

// 构建主席树，按SA序插入后缀位置
ct.init();
```

#### 2. 二分答案
```cpp
int left = 0, right = min(b - a + 1, d - c + 1);
while (left <= right) {
    int mid = (left + right) >> 1;
    if (check(a, b, c, d, mid)) {
        ans = mid;
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}
```

#### 3. 判定函数的巧思
```cpp
bool check(int a, int b, int c, int d, int mid) {
    // 1. 找到满足lcp(sa[rank], c) >= mid的rank区间
    pair<int, int> range = findLCPRange(c, mid);
    
    // 2. 查询该rank区间内是否有开头在[a, b-mid+1]的后缀
    return ct.countInRange(range.first, range.second, a, b - mid + 1) > 0;
}
```

### 🎯 技术要点

#### 1. LCP的单峰性质
在SA序中，与位置c的LCP呈**单峰分布**，峰值在 `rank[c]` 处。
- 用**二分**找到满足 `lcp ≥ mid` 的连续rank区间

#### 2. ST表的左开右闭查询
```cpp
// height[i] = lcp(sa[i-1], sa[i])
// 查询lcp(i, j)需要查询height数组的区间最小值
```

#### 3. 主席树的双重限制
- **权值维度**：后缀的实际编号 (1~n)
- **版本维度**：SA序的前缀 (按rank建版本)
- **查询**：区间rank内，位置在指定范围的后缀个数

## 📊 复杂度分析

### 时间复杂度
- **预处理**: O(n log n)
  - 后缀数组：O(n log n)
  - ST表：O(n log n)  
  - 主席树：O(n log n)
- **单次查询**: O(log²n)
  - 二分答案：O(log n)
  - 每次check：O(log n)
- **总复杂度**: O(n log n + m log²n)

### 空间复杂度
- **总空间**: O(n log n)

## 🔧 关键实现细节

### 1. height数组的正确理解
```cpp
// height[i] = lcp(sa[i-1], sa[i])
// 查询lcp(x, y)需要查询height数组的区间最小值
```

### 2. 二分边界的正确处理
```cpp
// 注意左开右闭区间的处理
// 边界情况的特殊处理
```

### 3. 主席树的版本管理
```cpp
// 按SA序建版本，权值是后缀位置
// 支持区间内指定权值范围的计数查询
```

## 🏆 算法亮点

1. **问题转化能力**：从求最值转化为判定问题
2. **可二分性发现**：洞察答案的单调性
3. **数据结构组合**：后缀数组+ST表+主席树的完美结合
4. **复杂度优化**：从O(mn)优化到O(m log²n)

## 📁 文件说明

- `P4094.cpp` - 最终AC解法（二分答案 + 后缀数组 + 主席树）
- `README.md` - 详细题解和算法分析
- `test_input.txt` - 测试数据

## 🎓 学习价值

这道题完美展示了：
- **算法思维的转化过程**
- **复杂数据结构的综合应用** 
- **竞赛编程中的优化技巧**

是学习高级字符串算法和可持久化数据结构的**顶级例题**！

---

*"真正的算法之美在于将复杂问题层层分解，最终用简洁的思路一击致命"* ⚡  
*最终解法实现完成 - 2024* ✨ 