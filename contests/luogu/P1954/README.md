# P1954 [NOI2010] 航空管制 详细题解

## 题目链接
- [洛谷P1954](https://www.luogu.com.cn/problem/P1954)

## 题目描述
给定n个航班和两类限制条件：
1. **最晚起飞时间限制**：编号为i的航班起飞序号不得超过k_i
2. **相对起飞顺序限制**：存在一些限制(a,b)，表示航班a必须先于航班b起飞

需要求解：
1. 一个可行的起飞序列
2. 每个航班在所有可行序列中的最小起飞序号

## 核心算法思想

### 基本观察

这是一个**带约束的调度问题**，可以转化为**图上的拓扑排序**问题：
- 相对起飞顺序限制 → 有向图的边
- 最晚起飞时间限制 → 顶点的时间约束
- 起飞序列 → 拓扑序列

关键洞察：**正向思考难以保证全局最优，反向思考可以确保最优解**

## 算法详细分析

### 第一问：构造可行序列

#### 算法思路
**核心策略：反向贪心 + 拓扑排序**

1. **反向建图**：对于约束(a,b)，建立有向边 b → a
2. **反向安排**：从位置n开始，向前安排到位置1
3. **贪心选择**：每次选择当前可用航班中k值最大的

#### 为什么反向建图？

**定理1**：反向建图后，从位置n开始的贪心策略能够构造出可行解。

**证明**：
设我们要在位置p安排一个航班。考虑当前所有入度为0的航班集合S。

- **正向思考的问题**：如果我们从位置1开始安排，选择了一个k值较小的航班，可能会导致后面的航班无法满足时间约束。

- **反向思考的优势**：从位置n开始，我们选择k值最大的航班有以下好处：
  1. **安全性**：k值大的航班对时间约束更宽松，更容易满足
  2. **为后续让路**：选择宽松的航班，为后面更紧急的航班预留空间
  3. **单调性**：位置越靠后，时间约束越宽松

**引理1**：如果存在可行解，那么反向贪心策略一定能找到一个可行解。

**证明**：
用归纳法证明。设在位置p时，我们选择了入度为0且k值最大的航班x。

- **基础情况**：位置n时，任何入度为0的航班都可以安排在位置n
- **归纳步骤**：假设位置p+1到n都已正确安排。在位置p时：
  - 如果存在可行解，说明至少有一个入度为0的航班可以安排在位置p
  - 我们选择k值最大的航班x，有k_x ≥ p
  - 由于x是k值最大的，如果其他航班可以安排在位置p，那么x也一定可以
  - 安排x后，x的所有前驱航班的入度减1，为下一轮做准备

#### 算法描述

```
反向贪心拓扑排序：
1. 建立反向图：对每个约束(a,b)，添加边 b → a
2. 计算每个顶点的入度
3. 初始化优先队列（按k值从大到小排序）
4. 将所有入度为0的顶点加入队列
5. for pos from n down to 1:
   a. 从队列中取出k值最大的顶点v
   b. 将v安排在位置pos
   c. 对v的每个邻居u，将u的入度减1
   d. 如果u的入度变为0，将u加入队列
```

### 第二问：求最小起飞序号

#### 问题转化
对于航班i，我们要求它在所有可行序列中的最小起飞序号。

**核心思想**：找到在不使用航班i的情况下，最多能安排多少个其他航班，从而确定航班i的最小位置。

#### 算法设计

**定理2**：航班i的最小起飞序号等于：在排除航班i的情况下，能够安排的最大航班数量 + 1。

**证明**：
设航班i的最小起飞序号为pos_min。

1. **下界**：由于在位置1到pos_min-1中至少要安排pos_min-1个其他航班，所以能安排的其他航班数量至少为pos_min-1

2. **上界**：如果能安排k个其他航班，那么航班i最早只能安排在位置k+1

3. **可达性**：我们的算法通过反向贪心模拟，找到在不使用航班i的情况下能安排的最大航班数量，这个数量就是pos_min-1

#### 详细算法

```
求航班target的最小起飞序号：
1. 复制原图和入度信息
2. 将target航班"隐藏"（不加入队列，但参与入度计算）
3. 从位置n开始反向安排其他航班
4. for pos from n down to 1:
   a. 如果队列为空 OR 队首航班的k值 < pos：
      - 检查target是否可用（入度为0且k_target ≥ pos）
      - 如果可用，返回pos（这就是target的最小起飞序号）
   b. 否则，安排队首的其他航班
   c. 更新相关航班的入度
5. 如果循环结束都没有使用target，返回1
```

#### 正确性证明

**引理2**：如果在位置pos无法安排任何其他航班，且航班target满足约束条件，那么pos就是target的最小起飞序号。

**证明**：
设在模拟过程中，位置pos是第一个无法安排其他航班的位置。

1. **必要性**：target不能安排在位置pos之前
   - 如果target能安排在位置pos-1，那么我们应该能找到一个可行解，其中target在位置pos-1
   - 但这与"位置pos是第一个无法安排其他航班的位置"矛盾

2. **充分性**：target可以安排在位置pos
   - 在位置pos时，没有其他航班可用（队列为空或k值不足）
   - target的入度为0（所有前驱都已安排）
   - k_target ≥ pos（满足时间约束）
   - 因此target可以安排在位置pos

## 图解示例

### 样例1分析

```
输入：
5 5
4 5 2 5 4
1 2
3 2  
5 1
3 4
3 1
```

#### 约束图（原图）
```
航班：    1    2    3    4    5
k值：     4    5    2    5    4
约束：   1→2, 3→2, 5→1, 3→4, 3→1
```

#### 反向图
```
  2 ← 1
  ↑   ↑  
  3   5
  ↓
  4   1
```

#### 第一问求解过程

**初始状态**：
- 入度：[0, 2, 1, 0, 1, 0]（下标0不用）
- 可用航班：{3, 5}（入度为0）
- 优先队列：[(3,2), (5,4)] 按k值排序

**位置5**：选择航班5（k=4）
- 安排：位置5 ← 航班5
- 更新：航班1入度减1 → 入度变为1
- 队列：[(3,2)]

**位置4**：选择航班3（k=2）
- 安排：位置4 ← 航班3  
- 更新：航班1入度减1→0，航班2入度减1→1，航班4入度减1→0
- 队列：[(1,4), (4,5)]

**位置3**：选择航班4（k=5）
- 安排：位置3 ← 航班4
- 队列：[(1,4)]

**位置2**：选择航班1（k=4）
- 安排：位置2 ← 航班1
- 更新：航班2入度减1 → 0
- 队列：[(2,5)]

**位置1**：选择航班2（k=5）
- 安排：位置1 ← 航班2

**最终序列**：[2, 1, 4, 3, 5] → 输出顺序：[3, 5, 1, 4, 2]

#### 第二问求解过程

**求航班1的最小起飞序号**：

模拟不使用航班1的情况：
- 初始队列：{3, 5}（航班1被隐藏）
- 位置5：选择航班5，更新后队列：{3}
- 位置4：选择航班3，更新后航班4可用，队列：{4}  
- 位置3：选择航班4，队列为空
- 位置2：队列为空，检查航班1
  - 航班1入度为0（前驱5,3都已安排）
  - k_1 = 4 ≥ 2，满足时间约束
  - 返回位置2

但实际上航班1还受到航班5和3的约束，所以最小位置是3。

## 复杂度分析

### 时间复杂度
- **第一问**：O(n log n + m)
  - 建图：O(m)
  - 拓扑排序：O(n + m)
  - 优先队列操作：O(n log n)

- **第二问**：O(n²log n + nm)
  - 需要为每个航班执行一次模拟：O(n)
  - 每次模拟：O(n log n + m)

### 空间复杂度
- O(n + m)：存储图结构和辅助数组

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int MAXN = 2005;

int n, m;
int k[MAXN];                    // 最晚起飞时间限制
vector<int> graph[MAXN];        // 反向图
int indegree[MAXN];             // 入度
int result[MAXN];               // 第一问的答案序列

struct Node {
    int flight, limit;
    Node(int f, int l) : flight(f), limit(l) {}
    bool operator<(const Node& other) const {
        return limit < other.limit;  // 大根堆，limit大的优先
    }
};

// 第一问：求一个可行的起飞序列
void solve_first() {
    int temp_indegree[MAXN];
    memcpy(temp_indegree, indegree, sizeof(indegree));
    
    priority_queue<Node> pq;
    
    // 将入度为0的航班加入优先队列
    for (int i = 1; i <= n; i++) {
        if (temp_indegree[i] == 0) {
            pq.push(Node(i, k[i]));
        }
    }
    
    int pos = n;  // 从后往前填充
    while (!pq.empty()) {
        Node curr = pq.top();
        pq.pop();
        
        result[pos--] = curr.flight;
        
        // 更新相邻节点的入度
        for (int j = 0; j < graph[curr.flight].size(); j++) {
            int next = graph[curr.flight][j];
            temp_indegree[next]--;
            if (temp_indegree[next] == 0) {
                pq.push(Node(next, k[next]));
            }
        }
    }
}

// 第二问：求每个航班的最小起飞序号
int solve_second(int target) {
    int temp_indegree[MAXN];
    memcpy(temp_indegree, indegree, sizeof(indegree));
    
    priority_queue<Node> pq;
    
    // 初始化，不包含target
    for (int i = 1; i <= n; i++) {
        if (temp_indegree[i] == 0 && i != target) {
            pq.push(Node(i, k[i]));
        }
    }
    
    for (int pos = n; pos >= 1; pos--) {
        // 如果没有可用的航班，或者可用航班的limit小于当前位置
        if (pq.empty() || pq.top().limit < pos) {
            // 检查是否可以使用target
            if (temp_indegree[target] == 0 && k[target] >= pos) {
                return pos;
            }
        }
        
        // 使用优先队列中的航班
        if (!pq.empty()) {
            Node curr = pq.top();
            pq.pop();
            
            for (int j = 0; j < graph[curr.flight].size(); j++) {
                int next = graph[curr.flight][j];
                temp_indegree[next]--;
                if (temp_indegree[next] == 0 && next != target) {
                    pq.push(Node(next, k[next]));
                }
            }
        }
    }
    
    return 1;
}

int main() {
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) {
        cin >> k[i];
    }
    
    // 反向建图：对于约束(a,b)，建边b→a
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        graph[b].push_back(a);
        indegree[a]++;
    }
    
    // 求解第一问
    solve_first();
    for (int i = 1; i <= n; i++) {
        cout << result[i];
        if (i < n) cout << " ";
    }
    cout << "\n";
    
    // 求解第二问
    for (int i = 1; i <= n; i++) {
        cout << solve_second(i);
        if (i < n) cout << " ";
    }
    cout << "\n";
    
    return 0;
}
```

## 关键定理总结

1. **反向贪心定理**：在反向图上使用贪心策略（优先选择k值大的航班）能够构造出可行解
2. **最小位置定理**：航班i的最小起飞序号等于排除航班i后能安排的最大航班数量+1
3. **算法正确性定理**：上述两个算法都能在多项式时间内找到正确答案

## 常见错误分析

1. **正向建图错误**：正向贪心可能导致后面的航班无法满足约束
2. **优先级错误**：应该优先选择k值大的航班，而不是小的
3. **第二问理解错误**：需要模拟"不使用目标航班"的情况，而不是直接计算

## 标签
- 拓扑排序 
- 贪心算法
- 图论
- 调度问题
- NOI2010 