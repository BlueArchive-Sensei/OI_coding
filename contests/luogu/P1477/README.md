# P1477 [NOI2008] 假面舞会

<div align="center">

![difficulty](https://img.shields.io/badge/难度-省选/NOI--orange)
![tag](https://img.shields.io/badge/标签-图论-blue)
![tag](https://img.shields.io/badge/标签-约束满足-blue)
![tag](https://img.shields.io/badge/标签-连通分量-blue)

</div>

## 🎯 问题本质

这是一道**约束满足问题**：给n个面具分配类别，使得所有"看到"关系都满足相邻类别的约束。

### 📝 题目转述

- 有n个面具，分为k类（k≥3）
- 第i类面具的人能看到第(i+1)类面具的人
- 第k类面具的人能看到第1类面具的人（形成环形）
- 给定m个"a看到b"的关系，求可能的最大和最小k值

## 🧮 数学建模

### 核心约束

如果面具a看到面具b，则：**类别[b] = (类别[a] + 1) mod k**

### 问题类型判断

1. **有环情况**：存在约束冲突 → k必须整除所有环长度
2. **无环情况**：纯链式约束 → k可以等于链的总长度

## 🔍 算法思路

### 第一步：建立约束图

对每个关系"a看到b"：
```cpp
add_edge(a, b, +1);  // 表示：类别[b] = 类别[a] + 1
add_edge(b, a, -1);  // 表示：类别[a] = 类别[b] - 1
```

**为什么要双向建边？**
- 不是为了构造反向边
- 而是为了在BFS中检查约束的一致性
- 从任何方向到达一个节点，距离都应该一致

### 第二步：BFS检测约束冲突

```cpp
void bfs(int start) {
    queue<int> q;
    q.push(start);
    vis[start] = true;
    dist[start] = 0;  // 相对类别距离
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        for (int i = head[u]; i; i = edges[i].next) {
            int v = edges[i].to;
            int w = edges[i].weight;
            
            if (!vis[v]) {
                // 第一次到达v，设定距离
                vis[v] = true;
                dist[v] = dist[u] + w;
                q.push(v);
            } else {
                // 再次到达v，检查约束一致性
                int expected = dist[u] + w;
                int actual = dist[v];
                if (expected != actual) {
                    // 约束冲突！检测到环
                    int cycle_len = abs(expected - actual);
                    cycles.push_back(cycle_len);
                }
            }
        }
    }
}
```

### 第三步：分析结果

#### 情况1：检测到环
- 所有环长度：L₁, L₂, ..., Lₘ
- 最大k值：gcd(L₁, L₂, ..., Lₘ)
- 最小k值：gcd的最小约数且≥3

#### 情况2：无环检测
- 所有连通分量都是链
- 最大k值：所有链长度之和
- 最小k值：3（题目下界）

## 📊 具体示例

### 示例1：单个环
```
输入: 1→2, 2→3, 3→1

BFS过程:
- 从1开始: dist[1] = 0
- 1→2: dist[2] = 0 + 1 = 1
- 2→3: dist[3] = 1 + 1 = 2  
- 3→1: expected = 2 + 1 = 3, actual = 0
- 冲突: |3 - 0| = 3 → 环长度3

结果: gcd(3) = 3, 输出 3 3
```

### 示例2：多个连通分量
```
输入: 1→2→3→1, 4→5→6→7→4

连通分量1: 环长度3
连通分量2: 环长度4
结果: gcd(3,4) = 1 < 3, 输出 -1 -1
```

### 示例3：链结构
```
输入: 1→2→3→4→5

无环检测，链长度5
结果: 输出 5 3
```

## 💡 关键洞察

### 为什么会有约束冲突？

当我们通过不同路径到达同一个节点时，如果计算出的"相对类别距离"不一致，说明存在矛盾的约束关系，这种矛盾只能通过类别的"周期性"来解决。

### 数学证明

设环长度为L，如果类别[v] = c，沿环走一圈后：
- 类别[v] = c + L (按约束计算)
- 类别[v] = c (实际值，因为回到原点)

要求：c = c + L (mod k) → L ≡ 0 (mod k) → k整除L

## 🔧 实现要点

1. **建图**: 双向建边确保约束检查的完整性
2. **遍历**: 对每个连通分量独立处理
3. **检测**: 通过距离冲突发现环
4. **计算**: 使用GCD求最大值，遍历约数求最小值

## 🎪 复杂度分析

- **时间复杂度**: O(n + m)，每个节点和边最多访问一次
- **空间复杂度**: O(n + m)，存储邻接表

## 🌟 算法优势

这个算法的巧妙之处在于：
1. **统一处理**: 同时处理简单环和复杂约束网络
2. **自动归约**: 将复杂约束自动转化为等价的环长度
3. **完整检测**: 不遗漏任何约束冲突

---

<div align="center">

**🌸 "约束的矛盾指向数学的和谐，这就是算法的美学！" —— ユウカ**

*Made with 💙 by Millennium Algorithm Club*

</div> 