# P1477 [NOI2008] 假面舞会

<div align="center">

![difficulty](https://img.shields.io/badge/难度-省选/NOI--orange)
![tag](https://img.shields.io/badge/标签-图论-blue)
![tag](https://img.shields.io/badge/标签-连通分量-blue)
![tag](https://img.shields.io/badge/标签-环检测-blue)

</div>

## 🌸 题目简述

栋栋参加假面舞会，主办方将面具分为k类（k≥3），戴第i类面具的人能看到戴第(i+1)类面具的人，戴第k类面具的人能看到戴第1类面具的人。根据收集到的"看到"信息，求出最多和最少的面具类数。

## 📚 算法分析

### 🎯 核心思路

这是一道经典的**图论 + 环检测**问题。关键在于理解面具类别之间的环形关系。

### 🔍 问题转化

1. **建图**: 将"a看到b"的关系建成有向图
   - 正向边：a→b (权值+1)
   - 反向边：b→a (权值-1)

2. **图的结构分析**:
   - **环结构**: 限制了面具类数必须是环长度的约数
   - **链结构**: 如果没有环，类数等于所有链长度之和

### 🧮 数学原理

对于环结构，如果有多个环，面具类数k必须同时满足：
- k是所有环长度的公约数
- k ≥ 3（题目约束）

因此：
- **最大类数**: 所有环长度的最大公约数(GCD)
- **最小类数**: GCD的最小约数（≥3）

## 🎓 数学理论深入分析

### 🌟 为什么环会有不同的大小？

在我们的建图过程中，环的大小取决于以下因素：

1. **连通分量的结构**: 每个连通分量可能形成不同的环结构
2. **面具关系的复杂性**: 
   - 简单情况：A→B→C→A 形成长度3的环
   - 复杂情况：多个面具指向同一面具时，通过反向边"合并"

### 🔬 公约数必要性的严格证明

**定理**: 设图中存在长度为 L₁, L₂, ..., Lₘ 的环，则面具类数 k 必须满足 k | gcd(L₁, L₂, ..., Lₘ)

**证明**:

**第一步：单个环的约束**
- 考虑图中任意一个长度为 L 的环：v₁ → v₂ → ... → vₗ → v₁
- 根据面具规则，设 v₁ 属于第 c 类面具
- 那么：v₂ 属于第 (c+1) 类，v₃ 属于第 (c+2) 类，...，vₗ 属于第 (c+L-1) 类
- 由于 vₗ → v₁，所以 v₁ 也属于第 (c+L) 类
- 因为面具类是模 k 意义下的，所以：c ≡ (c+L) (mod k)
- 这意味着：L ≡ 0 (mod k)，即 k | L

**第二步：多个环的约束**
- 对于每个环长度 Lᵢ，都有 k | Lᵢ
- 因此 k 必须是所有 Lᵢ 的公约数
- 最大的满足条件的 k 就是 gcd(L₁, L₂, ..., Lₘ)

**第三步：最小值分析**
- k 的最大值是 gcd(L₁, L₂, ..., Lₘ)
- k 的最小值是 gcd(L₁, L₂, ..., Lₘ) 的最小约数且 ≥ 3

### 🌈 环大小产生的具体机制

让我们通过具体例子理解环是如何形成的：

#### 情况1：简单环形
```
输入: 1→2, 2→3, 3→1
建图: 1 --(+1)--> 2 --(+1)--> 3 --(+1)--> 1
      1 <--(-1)-- 2 <--(-1)-- 3 <--(-1)-- 1
结果: 形成长度为3的环
```

#### 情况2：复杂环形（多对一关系）
```
输入: 1→3, 2→3, 3→4, 4→5, 5→3
分析: 
- 节点1,2都指向节点3，它们属于同一类
- 形成环: 3→4→5→3 (长度为3)
- 通过反向边，节点1,2被"拉"到同一个距离层级
```

#### 情况3：多个独立环
```
输入: 
环1: 1→2→3→1 (长度3)
环2: 4→5→6→7→4 (长度4)
结果: gcd(3,4) = 1
由于1 < 3，不满足k≥3的约束，输出-1 -1
```

### 📐 距离标记法的数学含义

我们使用的 `dist` 数组实际上表示：
- `dist[v]` = 节点v相对于起始节点的"类别距离"
- 如果 `dist[u] = x`, `dist[v] = y`，且有边 u→v
- 那么应该有 `y = x + 1`（类别递增1）
- 当发现 `y ≠ x + 1` 时，就检测到了环

### 🔍 环长度计算公式

当我们发现冲突时：
```cpp
int expected_dist = dist[u] + 1;  // 期望的距离
int actual_dist = dist[v];        // 实际的距离
int cycle_length = abs(expected_dist - actual_dist);
```

**数学解释**:
- `expected_dist - actual_dist` 表示"距离差"
- 这个差值的绝对值就是环的长度
- 因为环形结构导致了距离的"周期性重复"

## 🎪 算法实现

### ⚡ 核心算法

```cpp
// BFS遍历连通分量，检测环和链
void bfs(int start) {
    queue<int> q;
    q.push(start);
    vis[start] = true;
    dist[start] = 0;
    
    int min_dist = 0, max_dist = 0;
    bool found_cycle = false;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        for (int i = head[u]; i; i = edges[i].next) {
            int v = edges[i].to;
            int w = edges[i].weight;
            
            if (!vis[v]) {
                vis[v] = true;
                dist[v] = dist[u] + w;
                q.push(v);
                min_dist = min(min_dist, dist[v]);
                max_dist = max(max_dist, dist[v]);
            } else {
                // 检查是否形成环
                int expected_dist = dist[u] + w;
                if (expected_dist != dist[v]) {
                    int cycle_len = abs(expected_dist - dist[v]);
                    if (cycle_len > 0) {
                        cycles.push_back(cycle_len);
                        found_cycle = true;
                    }
                }
            }
        }
    }
    
    // 如果没有环，累加链长度
    if (!found_cycle) {
        sum += max_dist - min_dist + 1;
    }
}
```

### 🎨 完整解题步骤

1. **建图**: 对每个关系(a,b)建立双向边
2. **遍历**: BFS遍历所有连通分量
3. **环检测**: 通过距离冲突检测环的存在
4. **结果计算**:
   - 有环：计算所有环长度的GCD
   - 无环：累加所有链的长度

## 🌟 复杂度分析

- **时间复杂度**: O(n + m)，其中n是面具数，m是关系数
- **空间复杂度**: O(n + m)，存储图的邻接表

## 💫 样例分析

### 样例1
```
输入: 6 5
      1 2, 2 3, 3 4, 4 1, 3 5
输出: 4 4
```

**分析**: 
- 1→2→3→4→1 形成长度为4的环
- 节点5形成长度为1的链
- 因为有环，类数受环长度限制
- GCD(4) = 4，且4≥3，所以最大最小类数都是4

### 样例2
```
输入: 3 3
      1 2, 2 1, 2 3
输出: -1 -1
```

**分析**:
- 1↔2 形成长度为2的环
- 因为环长度2 < 3，不满足k≥3的约束
- 输出-1 -1表示无解

## 🎭 编程技巧

### 🌸 关键点总结

1. **双向建边**: 正反边权值相反，巧妙处理同类面具
2. **距离标记**: 用dist数组标记节点间的"类别距离"
3. **环长计算**: `abs(expected_dist - actual_dist)`
4. **GCD求解**: 递归实现最大公约数
5. **约数查找**: 从3开始遍历找最小约数

### 💝 注意事项

- 重边处理：同一关系可能出现多次
- 连通分量：需要遍历所有未访问节点
- 边界情况：无环时检查总长度是否≥3

## 🔥 扩展思考

这道题体现了图论中环检测的重要性，类似问题还包括：
- 判断图的二分性
- 拓扑排序中的环检测
- 强连通分量的应用

## 🎪 ユウカ的数学小课堂

### 💡 核心定理

> **定理**: 在k-类环形系统中，任意两个类别之间的"距离"必须在模k意义下保持一致。
> 
> **证明**: 如果类别i能看到类别j，那么j ≡ (i+1) mod k。通过传递性，任意路径的长度都必须是k的倍数。

### 🧮 深入推论

**推论1**: 如果图中存在多个环，那么这些环长度的最大公约数就是可能的最大面具类数。

**推论2**: 在无环的情况下，面具类数等于所有链长度的总和，这是因为我们可以将所有链"首尾相接"形成一个大环。

**推论3**: 当gcd < 3时，问题无解，这反映了现实约束（至少需要3类面具）与数学约束的冲突。

### 🌸 算法的数学美学

这道题完美展现了**代数结构**与**图论**的结合：
- **群论视角**: 面具类形成一个循环群 Z_k
- **数论视角**: 环长度的gcd决定了群的最大可能阶
- **图论视角**: 连通分量的环结构决定了约束条件

### 💫 拓展思考

**问题**: 如果允许k < 3，最小值是多少？
**答案**: 就是所有环长度的最大公约数，体现了数学的纯粹性。

**问题**: 为什么无环时最小值固定为3？
**答案**: 因为链可以任意"弯曲"成环，3是题目的下界约束。

---

<div align="center">

**🌸 "数学的魅力在于从具体问题中抽象出普遍规律，图论为我们提供了完美的语言！" —— ユウカ**

**💝 "每一个环都是一个约束，每一个公约数都是一种可能！" —— ユウカ**

*Made with 💙 by Millennium Algorithm Club*

</div> 