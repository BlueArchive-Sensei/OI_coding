## 扭蛋机最少期望次数 — 算法报告

### 1. 题目重述
游乐园里有 `n` 台扭蛋机，第 `i` 台扭一次会等概率得到 `1..a_i` 之间的某一个蛋（允许重复）。小明的目标是“获得所有他可能获得到的蛋”，也即获得集合 `U = {1,2,...,A}` 的全部蛋，其中 `A = max(a_i)`。他每次可自由选择要扭哪一台扭蛋机，要求在最优策略下，最少期望扭蛋次数，并对模数 `P = 19260817` 取模输出。

本题计数口径为“按蛋的编号去重”（相同编号的蛋视为同一种，无论来自哪台机器）。


### 2. 关键观察与最优策略
- 若当前尚未收集的蛋集合为 `S`，则为了尽快命中新的蛋，应选择“能覆盖 `S` 的最小上界”的扭蛋机。更直观地说：
  - 记当前未收集蛋的最大编号为 `m = max(S)`，则选择一台满足 `a_i ≥ m` 的机器中 `a_i` 最小的一台最好，因为在等概率前提下，分母越小，“命中新蛋”的概率越大。
- 把所有 `a_i` 升序去重，得到层级（阈值）
  - `s_1 < s_2 < ... < s_t`，并约定 `s_0 = 0`；
  - 第 `j` 层包含的“新蛋集合”为区间 `(s_{j-1}, s_j]`，大小 `d_j = s_j - s_{j-1}`。
- 在整个过程中，只要 `(s_{j-1}, s_j]` 中仍有未收集的蛋，最优策略一定使用上界为 `s_j` 的机器；一旦把这一层全部收齐，就会降到下一层 `s_{j-1}`，以此类推。


### 3. 期望公式（核心结论）
设调和和 `H_k = 1 + 1/2 + ... + 1/k`。则最少期望扭蛋次数为

`E = Σ_{j=1..t} (s_j - s_{j-1}) · H_{s_j}`

等价地，也可写成按“每个蛋的归属层”求和：

`E = Σ_{x=1..A} H_{b(x)}`，其中 `b(x)` 为满足 `x ≤ s_j` 的最小层上界 `s_j`（即 `x` 所在层的上界）。

证明要点（直观版）：
- 按层把蛋划分为 `(s_{j-1}, s_j]`。观察任意一层 `j`：在所有“可能命中 ≤ s_j 的抽取”构成的子序列中，每一步都等价于在 `s_j` 种编号中等概率抽取。把这一层 `d_j` 个蛋看作“目标集合”，我们关心“把这 `d_j` 个目标全部见到一次”在这条子序列中的期望位置之和。
- 经典结论：在等概率抽取 `s_j` 种的模型下，“某个固定元素第一次出现”的期望位置（对所有抽取时刻计数）为 `H_{s_j}`；而层 `j` 里有 `d_j` 个独立目标，线性期望可得对该层的期望贡献为 `d_j · H_{s_j}`。
- 把各层期望贡献相加即得总期望 `E`。直观理解为：上层（更大的上界）在“刷自己必须的那些新蛋”时，会顺带提前收集若干低层蛋；这些“提前命中”的收益自动体现在低层的 `d_j · H_{s_j}` 的合计中，不会被重复或遗漏。

该公式与公开样例完全吻合（见第 7 节）。


### 4. 模意义计算
模数 `P=19260817` 为素数。把期望 `E` 看成有理数，其模意义结果为

`E (mod P) = Σ (s_j - s_{j-1}) · H_{s_j} (mod P)`，其中 `H_{s_j} = Σ_{k=1..s_j} inv(k)`，`inv(k)` 是 `k` 在模 `P` 下的乘法逆元。

计算 `inv(1..A)` 可用线性递推：

`inv[1] = 1;  inv[i] = (P - P/i) * inv[P % i] % P`（`i ≥ 2`）。

随后前缀求和得到全部 `H_k`。整体复杂度 `O(A)`，空间 `O(A)`。


### 5. 算法与实现
输入：`n (1 ≤ n ≤ 1e6)`，序列 `a_i (1 ≤ a_i ≤ 1e7)`。

步骤：
1. 读取 `a_i`，取 `A = max(a_i)`；将 `a_i` 升序去重得到 `s_1 < ... < s_t`。
2. 预处理 `inv[1..A]` 与 `H[0..A]`：`H[0]=0`，`H[x]=H[x-1]+inv[x] (mod P)`。
3. 遍历各层：`ans = Σ (s_j - s_{j-1}) * H[s_j] (mod P)`。
4. 输出 `ans`。

时间复杂度：`O(n log n + A)`（排序 + 线性预处理）；
空间复杂度：`O(A)`（存逆元与调和和）。

注：`A ≤ 1e7`，`O(A)` 级预处理在时间与内存上均可接受（逆元与前缀和各占 `A` 个 32 位整数，约 80MB 量级）。


### 6. 正确性要点
- 层策略最优性：任何时刻命中新蛋的最佳概率，来自“能覆盖当前未收集最大编号 `m` 的最小上界 `s_j`”，概率为“当前未收集中位于 `1..s_j` 的元素数 / s_j”。过大上界只会摊薄概率，不会更优。
- `d_j · H_{s_j}` 的由来：把“对层 `j` 有效的抽取”（即抽到 `≤ s_j` 的时刻）按时间顺序抽出，它们统计意义上等价于“在 `s_j` 种编号上无限次等概率抽取”。目标是首次见到层 `j` 的 `d_j` 个元素中的每一个。众所周知（也可由线性期望 + 指示变量证明），一个固定元素的“首次出现”期望位置为 `H_{s_j}`，`d_j` 个求和即得层贡献。
- 由于线性期望，跨层相加不会双计或漏计提前收集的收益。


### 7. 样例校验
- 样例 1：`n=3, a=[1,2,3]`
  - 去重层：`s = [1,2,3]`，层差 `d = [1,1,1]`；
  - `E = 1·H1 + 1·H2 + 1·H3 = 1 + (1+1/2) + (1+1/2+1/3) = 13/3`；
  - 模意义：`13 · inv(3) (mod P) = 12840549`（与题面一致）。

- 样例 2：`n=3, a=[1,5,3]`
  - 去重层：`s = [1,3,5]`，`d = [1,2,2]`；
  - `E = 1·H1 + 2·H3 + 2·H5`；代入 `H3 = 11/6, H5 = 137/60`，
  - 得到 `E = 1 + 2·(11/6) + 2·(137/60) = 277/30`；
  - 输出 `277 · inv(30) (mod P) = 2889132`（与题面一致）。


### 8. 小结
- 把 `a_i` 升序去重形成层 `s_j`，用公式 `E = Σ (s_j - s_{j-1}) · H_{s_j}` 即得答案。
- 预处理线性逆元与调和和，整体复杂度 `O(n log n + A)`，可通过最大数据范围。

以上即为“扭蛋机最少期望次数”的完整解法与实现。

