## 子序列标题链计数问题 — 算法报告

### 1. 问题描述
- 给定字母表大小 `m`（允许重复用字）。
- 给定严格递减的长度序列 `a1 > a2 > ... > an`（`n ≥ 2`）。
- 第 1 个标题 `S1` 的长度为 `a1`；对 `i ≥ 2`，`Si` 必须是 `S{i-1}` 的一个子序列（按相对顺序保留部分字符）。
- 计数口径：按“字符串去重”计数（同一字符串只算一次）。
- 结果对 `MOD = 1e9+7` 取模。

目标：计算不同“标题链” `(S1 → S2 → … → Sn)` 的总数（模 `MOD`）。


### 2. 建模与符号
- 记一步从长度 `A` 到 `B`（`A > B`）的“收缩”计数函数为
  - `W(A,B) := # { 长度为 A 的串 s | s 包含固定长度 B 的串 t 作为子序列 }`。
- 关键事实：对固定的 `A,B,m`，`W(A,B)` 与 `t` 的具体内容无关。

整条链的计数可拆分为：先选 `Sn`，随后对每个 `i` 统计能“覆盖”既定 `Si` 的所有 `S{i-1}` 数量。由乘法原理：


### 3. 结论公式（闭式）
- 设 `A ≥ B ≥ 0`。则

  `W(A,B) = Σ_{k=B}^{A} C(A,k) · (m-1)^{A-k} = Σ_{t=0}^{A-B} C(A,t) · (m-1)^t`。

- 因而整题答案

  `Ans = m^{a_n} · Π_{i=2}^{n} W(a_{i-1}, a_i)  (mod MOD)`。

这里 `m^{a_n}` 是末尾串 `Sn` 的选择数；每个 `W(a_{i-1}, a_i)` 是“上一层能覆盖下一层”的计数，且独立于 `Si` 的具体内容。


### 4. 证明概要
#### 4.1 动态规划到闭式
固定目标串 `t`（长度 `B`），令 `dp[i][j]` 表示长度为 `i` 的前缀能匹配 `t` 的前 `j` 个字符的不同字符串数。转移：
- 放置“非所需字符”（`m-1` 种），匹配进度不变：`dp[i+1][j] += dp[i][j] · (m-1)`。
- 放置“正好所需字符”（`1` 种），匹配进度前进：`dp[i+1][j] += dp[i][j-1]`。

可归纳得

`dp[i][j] = C(i, j) · (m-1)^{i-j}`。

于是长度为 `A` 的串中“至少匹配到 `B` 个”（即包含 `t` 为子序列）的计数为

`Σ_{j=B}^{A} dp[A][j] = Σ_{j=B}^{A} C(A, j) · (m-1)^{A-j}`，

从而得到 `W(A,B)` 的闭式，且与 `t` 的具体内容无关。

#### 4.2 乘法原理
- 先选定末尾串 `Sn`，共有 `m^{a_n}` 种。
- 倒推到 `S{i-1}`：所有长度 `a_{i-1}` 的串中能覆盖固定 `Si` 的数量恒为 `W(a_{i-1}, a_i)`。
- 各层选择相互独立，乘法原理得到结论式。


### 5. 算法设计
闭式中 `W(A,B)` 是二项式前缀和。设 `Δ = A - B`，则

`W(A,B) = Σ_{t=0}^{Δ} C(A,t) · (m-1)^t`。

直接逐项累加，利用

`C(A,0)=1`, `C(A,t+1) = C(A,t) · (A - t)/(t + 1)`（模意义下用乘法逆元）。

为避免大规模阶乘预处理，仅需预处理 `inv[x] = (x)^{-1} (mod MOD)`，其中 `1 ≤ x ≤ (a1 - an)`，并在线递推组合数与幂。

#### 5.1 步骤
1. 读入 `n, m` 与 `a[1..n]`。
2. 预处理 `inv[1..(a1 - an)]` 的乘法逆元（线性递推：`inv[i] = MOD - (MOD/i) * inv[MOD % i] % MOD`）。
3. `ans ← m^{a_n} (mod MOD)`（快速幂）。
4. 对 `i=2..n`：
   - `A ← a_{i-1}`, `Δ ← A - a_i`，`comb ← 1`, `pw ← 1`, `sum ← 0`；
   - 对 `t=0..Δ`：`sum += comb * pw`；随后
     - `comb = comb * (A - t) % MOD * inv[t+1] % MOD`；
     - `pw = pw * (m-1) % MOD`；
   - `ans = ans * sum % MOD`。
5. 输出 `ans`。


### 6. 正确性论证要点
- `dp` 转移与闭式等价性：二项式恒等式可由归纳或生成函数佐证。
- `W(A,B)` 对目标串 `t` 的内容独立，确保不同层之间的乘法拆解成立。
- 由于所有计数均在模 `MOD` 下运算，`A - t` 与 `t+1` 不为 `MOD` 倍数（`MOD` 为大素数），逆元存在。


### 7. 复杂度分析
- 令总长度降幅 `D := a1 - an`。则
  - 时间复杂度：`O(n + D)`（每个层差贡献一次线性累加，总和为 `D`）。
  - 空间复杂度：`O(D)`（仅存 `inv[1..D]`）。

在题面范围（`D ≤ 10^7`）内，可通过合适的实现与 `fast-io` 达到满分。


### 8. 边界与健壮性
- `m = 1`：有且仅有一种字符。对任意 `A > B`，`W(A,B) = 1`，整条链唯一，`Ans = 1`。
- `B = 0`：`W(A,0) = Σ_{t=0}^{A} C(A,t) (m-1)^t = m^A`，与常识一致（“包含空串”为真）。
- 输入保证 `a1 > a2 > ... > an > 0`；若不满足则应直接返回 `0` 或报错（视评测约定）。


### 9. 实现细节建议
- 统一用 64 位中间变量再取模，避免乘法溢出。
- `(m-1)` 可能为负（当读入处理导致），先正规化到 `[0, MOD)`。
- 不需要阶乘/逆阶乘至 `a1` 级别；仅需 `inv` 到 `D=a1-an`，节省内存。
- 若内存受限可分块计算 `inv`；通常 `O(D)` 的数组在 1e7 级别也可以接受（约 40–80MB）。


### 10. 伪代码
```text
read n, m
read a[1..n]
MOD ← 1e9+7
ans ← pow_mod(m, a[n])
D ← a[1] - a[n]
precompute inv[1..D]

for i from 2 to n:
    A ← a[i-1]
    Δ ← A - a[i]
    comb ← 1        // C(A,0)
    pw ← 1          // (m-1)^0
    sum ← 0
    for t from 0 to Δ:
        sum ← (sum + comb * pw) mod MOD
        comb ← comb * (A - t) % MOD * inv[t + 1] % MOD
        pw   ← pw * (m - 1) % MOD
    ans ← ans * sum % MOD

print ans
```


### 11. 样例校验
- 样例：`n=2, m=2, a=[3,1]`
  - `W(3,1) = C(3,1)+C(3,2)+C(3,3) = 3+3+1 = 7`
  - `Ans = 2^{1} · 7 = 14`，与公开样例一致。


### 12. 扩展讨论
- 若采用“按位置计数（不去重）”，答案为 `m^{a1} · Π C(a_{i-1}, a_i)`，与本题口径不同。
- 本题本质上可视为“固定子序列出现”的计数，其核心量 `W(A,B)` 与二项分布尾和同构；亦可用生成函数给出等价推导。
- 若允许字母表随层变化或对子序列施加额外约束，可在 `W(A,B)` 处替换为相应的 DP/自动机计数因子。

